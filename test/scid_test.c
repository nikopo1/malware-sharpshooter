#include <sys/types.h>	/* open & other */
#include <sys/stat.h>	/* open */
#include <sys/ioctl.h>	/* guess who */
#include <fcntl.h>	/* for open */
#include <unistd.h>	/* for getpid */
#include <string.h>	/* strerror */
#include <errno.h>

#include <stdio.h>

#include "../include/scid.h"

int main(void)
{
	int fd, fd2, ret, count;
	sctrace_t sct;
	scid_info_t info;
	info.pid = getpid();
	info.sc_no = 5; /* 5 is open syscall */
	/* open and set monitoring pid to getpid() */
	fd = open("/proc/scid", O_RDWR);
	if(fd < 0) {
		perror("device open failed");
		return -1;
	}
	ret = ioctl(fd, IOCTL_SET_PID, &info);
	if(ret) {
		printf("ioctl set pid error %d\n", ret);
		return -1;
	}
	/* set to monitor open syscalls */
	ret = ioctl(fd, IOCTL_ADD_SYSCALL, &info);
	if(ret) {
		printf("ioctl add syscall error %d (%s)\n",
				errno, strerror(errno));
		return -1;
	}

	/* attempt to create+open a new file, this call should be
	 * intercepted */
	fd2 = open("ceva.txt", O_CREAT | O_RDWR, 0744);
	if(fd2 < 0) {
		perror("test open failed:");
		return -1;
	}
	/* attempt to stop monitoring a syscall that was never monitored
	 * (never IOCTL_ADD_SYSCALLed) */
	info.sc_no = 4;
	ret = ioctl(fd, IOCTL_DEL_SYSCALL, &info);
	if(ret) {
		/* no panic, this was meant to fail */
		perror("error untrace non traced syscall");
	}
	/* stop monitoring the open syscall */
	info.sc_no = 5;
	ret = ioctl(fd, IOCTL_DEL_SYSCALL, &info);
	if(ret) {
		perror("ioctl del failed");
		return  -1;
	}

	/* read history from driver */
	printf("Attempting to read count module param\n");
	ret = ioctl(fd, IOCTL_COUNT_HISTORY, &count);
	if(ret) {
		perror("ioctl count failed");
		return -1;
	}
	printf("Attempting to read history entry\n");
	while(count) {
		ret = ioctl(fd, IOCTL_READ_HISTORY, &sct);
		if(ret) {
			perror("ioctl read failed");
			return -1;
		}
		printf("syscall=%d ebx=%ld ecx=%ld edx=%ld esi=%ld edi=%ld ret=%ld\n",
				sct.sc_no,
				sct.sc_params.ebx,
				sct.sc_params.ecx,
				sct.sc_params.edx,
				sct.sc_params.esi,
				sct.sc_params.edi,
				sct.ret);
		count--;
	}
	close(fd);
	return 0;
}
