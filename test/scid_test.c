#include <sys/types.h>	/* open & other */
#include <sys/stat.h>	/* open */
#include <sys/ioctl.h>	/* guess who */
#include <fcntl.h>	/* for open */
#include <unistd.h>	/* for getpid */
#include <string.h>	/* strerror */
#include <errno.h>

#include <stdio.h>

#include "../include/scid.h"

int main(void)
{
	int fd, fd2, ret;
	scid_info_t info;
	info.pid = getpid();
	info.sc_no = 5; /* 5 is open syscall */

	fd = open("/proc/scid", O_RDWR);
	if(fd < 0) {
		perror("device open failed");
		return -1;
	}
	ret = ioctl(fd, IOCTL_SET_PID, &info);
	if(ret) {
		printf("ioctl set pid error %d\n", ret);
		return -1;
	}
	close(fd);

	fd = open("/proc/scid", O_RDWR);
	if(fd < 0) {
		perror("device open failed");
		return -1;
	}
	ret = ioctl(fd, IOCTL_ADD_SYSCALL, &info);
	if(ret) {
		printf("ioctl add syscall error %d (%s)\n", errno, strerror(errno));
		return -1;
	}
	close(fd);

	fd2 = open("ceva.txt", O_CREAT | O_RDWR, 0744);
	if(fd2 < 0) {
		perror("test open failed:");
		return -1;
	}

	info.sc_no = 4;
	fd = open("/proc/scid", O_RDWR);
	if(fd < 0) {
		perror("device open failed");
		return -1;
	}
	ret = ioctl(fd, IOCTL_DEL_SYSCALL, &info);
	if(ret) {
		/* no panic, this was meant to fail */
		perror("error untrace non traced syscall");
	}
	info.sc_no = 5;
	ret = ioctl(fd, IOCTL_DEL_SYSCALL, &info);
	if(ret) {
		perror("ioctl del failed");
		return  -1;
	}
	close(fd);
	return 0;
}
