#include "scdecoder.h"
#include <string.h>
#include <stdio.h>
#include <iostream>

SCDecoder::SCDecoder(const char *pathfile)
{
	pugi::xml_parse_result result = doc.load_file(pathfile);
	if(!result) {
		std::cout<<"Failure to read xml file"<<std::endl;
	}
}

bool SCDecoder::load_file(const char *pathfile)
{
	return doc.load_file(pathfile);
}

unsigned char SCDecoder::decode_argument_type(const char *string)
{
	if(strcmp(string, STR_TYPE_NONE) == 0)
		return TYPE_NONE;
	if(strcmp(string, STR_TYPE_INT) == 0)
		return TYPE_INT;
	if(strcmp(string, STR_TYPE_FD) == 0)
		return TYPE_FD;
	if(strcmp(string, STR_TYPE_PCHAR) == 0)
		return TYPE_PCHAR;
	if(strcmp(string, STR_TYPE_PVOID) == 0)
		return TYPE_PVOID;
	if(strcmp(string, STR_TYPE_USHORT) == 0)
		return TYPE_USHORT;
	if(strcmp(string, STR_TYPE_SIZE_T) == 0)
		return TYPE_SIZE_T;
	if(strcmp(string, STR_TYPE_VOID) == 0)
		return TYPE_VOID;
	/* only in case of error */
	return TYPE_NONE;
}

unsigned char SCDecoder::decode_argument_direction(const char *string)
{
	if(strcmp(string, STR_DIR_NONE) == 0)
		return DIR_NONE;
	if(strcmp(string, STR_DIR_IN) == 0)
		return DIR_IN;
	if(strcmp(string, STR_DIR_OUT) == 0)
		return DIR_OUT;
	if(strcmp(string, STR_DIR_INOUT) == 0)
		return DIR_INOUT;
	/* only in case of error */
	return DIR_NONE;
}

param_t SCDecoder::decode_argument(char *xpath)
{
	param_t ret;
	memset(&ret, 0, sizeof(param_t));
	pugi::xpath_node build_tool = doc.select_single_node(xpath);
	if(build_tool) {
		ret.type  = decode_argument_type(build_tool.node().attribute(XML_TYPE_ATTR).value());
		ret.dir   = decode_argument_direction(build_tool.node().attribute(XML_DIR_ATTR).value());
	}
	return ret;
}

syscall_t SCDecoder::decode(sctrace_t sct)
{
	syscall_t ret;
	char xpath[128] = {0};
	memset(&ret, 0, sizeof(syscall_t));
	ret.syscall_no = sct.sc_no;
	/* ebx */
	sprintf(xpath, "/syscalls/syscall[@no=\"%d\"]/ebx", sct.sc_no);
	ret.param[0] = decode_argument(xpath);
	ret.param[0].value = sct.sc_params.ebx;
	/* ecx */
	sprintf(xpath, "/syscalls/syscall[@no=\"%d\"]/ecx", sct.sc_no);
	ret.param[1] = decode_argument(xpath);
	ret.param[1].value = sct.sc_params.ecx;
	/* edx */
	sprintf(xpath, "/syscalls/syscall[@no=\"%d\"]/edx", sct.sc_no);
	ret.param[2] = decode_argument(xpath);
	ret.param[2].value = sct.sc_params.edx;
	/* esi */
	sprintf(xpath, "/syscalls/syscall[@no=\"%d\"]/esi", sct.sc_no);
	ret.param[3] = decode_argument(xpath);
	ret.param[3].value = sct.sc_params.esi;
	/* edi */
	sprintf(xpath, "/syscalls/syscall[@no=\"%d\"]/edi", sct.sc_no);
	ret.param[4] = decode_argument(xpath);
	ret.param[4].value = sct.sc_params.edi;
	/* ebp */
	sprintf(xpath, "/syscalls/syscall[@no=\"%d\"]/ebp", sct.sc_no);
	ret.param[5] = decode_argument(xpath);
	ret.param[5].value = sct.sc_params.ebp;
	/* eax */
	sprintf(xpath, "/syscalls/syscall[@no=\"%d\"]/eax", sct.sc_no);
	ret.param[6] = decode_argument(xpath);
	ret.param[6].value = sct.sc_params.eax;
	/* return value is the las element */
	sprintf(xpath, "/syscalls/syscall[@no=\"%d\"]/ret", sct.sc_no);
	ret.param[7] = decode_argument(xpath);
	ret.param[7].value = sct.ret;
	return ret;
}
