#include "malspec.h"
#include <map>

/*
 * All the edges have equal weights, so a simple BFS will be enough for
 * extracting the minimal transversal tree
 */
std::vector<Graph*> minimalTransversal(Graph* graph) {
	unsigned int i, j;
	std::vector< Graph* > result;
	std::vector< Vertex* > vertexs = graph->getVertexs();
	Graph *p;
	std::vector< std::pair<Vertex*, Vertex*> > transversal;
	for(i = 0; i < vertexs.size(); i++)
		vertexs[i]->setVisited(false);

	for(i = 0; i < vertexs.size(); i++) {
		if(!vertexs[i]->isVisited()) {
			transversal.clear();
			graph->bfs_transversal(vertexs[i], transversal);
			if(transversal.size() > 0) {
				p = graph->vertex_copy();
				for(j = 0; j < transversal.size(); j++)
					p->addEdge(transversal[j].first, transversal[j].second);
				p->clear_isolated_vertexs();
				result.push_back(p);
			}
		}
	}
	return result;
}

/*
 * Returns the minimal contrast edge set of graph1 with respect to
 * graph2.
 */
std::vector<Graph*> minimalContrastEdgeSets(Graph *graph1, Graph *graph2) {
	Graph *complement;
	std::vector<int> coresp;
	std::vector<Graph*> min_trans;
	std::vector<Graph*> result;
	/* determine the maximal common edge set between graph1 and
	 * graph2 */
	coresp = graph1->maximalCommonEdgeSet(graph2);

	/* compute complement of graph1 with respect to the maximal
	 * common edge set */
	complement = graph1->subgraphComplement(coresp);

	/* compute the minimal traversal of the complement, which will
	 * be the minimal contrast edge set */
	result = minimalTransversal(complement);

	return result;
}


std::vector<Graph*> minimalContrastVertexSets(Graph *graph1, Graph *graph2) {
	unsigned int i;
	std::vector<Graph*> result;
	std::vector<Vertex*> vertexs1 = graph1->getVertexs();
	std::vector<Vertex*> vertexs2 = graph2->getVertexs();
	std::map< int, std::vector<Vertex*> > part1;
	std::map< int, std::vector<Vertex*> > part2;

	for(i = 0; i < vertexs1.size(); i++)
		part1[vertexs1[i]->info.syscall_no].push_back(vertexs1[i]);

	for(i = 0; i < vertexs2.size(); i++)
		part2[vertexs2[i]->info.syscall_no].push_back(vertexs2[i]);

	// TODO 1: generate all subsets with k elements, where k is the
	// number of elements of a cell from the second partition

	// TODO 2: remove supergraphs of other graphs in the set

	/*
	 * Not necessary, we'll consider single vertex graphs as trivial
	 * cases of specifications
	 */
	return result;
}

/*
 * Determines the minimal contrast subgraph set of the first
 * graph with respect to the second graph given as parameter
 */
std::vector<Graph*> minimalContrastSubgraphSet(Graph *graph_positive, Graph *graph_negative) {

	std::vector<Graph*> contr_edge   = minimalContrastEdgeSets(graph_positive, graph_negative);
	std::vector<Graph*> contr_vertex = minimalContrastVertexSets(graph_positive, graph_negative);
	// TODO 1: remove graphs which are supergraphs of others in
	// the contrast edge set

	// TODO 2: remove contrast vertex sets which are subgraphs of
	// contrast vertex sets

	return contr_edge;
}
