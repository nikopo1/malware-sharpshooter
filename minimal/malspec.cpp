#include "malspec.h"
#include <map>

/*
 * All the edges have equal weights, so a simple BFS will be enough for
 * extracting the minimal transversal tree
 */
std::vector<Graph*> minimal_transversal(Graph* graph)
{
	unsigned int i, j;
	std::vector< Graph* > result;
	std::vector< Vertex* > vertexs = graph->getVertexs();
	Graph *p;
	std::vector< std::pair<Vertex*, Vertex*> > transversal;
	for(i = 0; i < vertexs.size(); i++)
		vertexs[i]->set_visited(false);

	for(i = 0; i < vertexs.size(); i++) {
		if(!vertexs[i]->is_visited()) {
			transversal.clear();
			graph->bfs_transversal(vertexs[i], transversal);
			if(transversal.size() > 0) {
				p = graph->vertex_copy();
				for(j = 0; j < transversal.size(); j++)
					p->add_edge(transversal[j].first, transversal[j].second);
				p->clear_isolated_vertexs();
				result.push_back(p);
			}
		}
	}
	return result;
}

/*
 * Returns the minimal contrast edge set of graph1 with respect to
 * graph2.
 */
std::vector<Graph*> minimal_contrast_edge_sets(Graph *graph1, Graph *graph2)
{
	unsigned int i;
	Graph *complement;
	std::vector<int> coresp(graph1->getVertexs().size(), VERTEX_NONE);
	std::vector<int> aux;
	std::vector<Graph*> min_trans;
	std::vector<Graph*> result;
	/* determine the maximal common edge set between graph1 and
	 * graph2 */
	if(graph1->getVertexs().size() < graph2->getVertexs().size()) {
		coresp = graph1->maximal_common_edge_set(graph2);
	} else {
		aux = graph2->maximal_common_edge_set(graph1);
		/* we have to reverse the matching nodes vector */
		for(i = 0; i < aux.size(); i++)
			if(aux[i] != VERTEX_NONE)
				coresp[aux[i]] = i;
	}

	/* compute complement of graph1 with respect to the maximal
	 * common edge set */
	complement = graph1->subgraph_complement(coresp);

	/* compute the minimal traversal of the complement, which will
	 * be the minimal contrast edge set */
	result = minimal_transversal(complement);

	return result;
}


std::vector<Graph*> minimal_contrast_vertex_sets(Graph *graph1, Graph *graph2)
{
	unsigned int i;
	std::vector<Graph*> result;
	std::vector<Vertex*> vertexs1 = graph1->getVertexs();
	std::vector<Vertex*> vertexs2 = graph2->getVertexs();
	std::map< int, std::vector<Vertex*> > part1;
	std::map< int, std::vector<Vertex*> > part2;

	for(i = 0; i < vertexs1.size(); i++)
		part1[vertexs1[i]->info.syscall_no].push_back(vertexs1[i]);

	for(i = 0; i < vertexs2.size(); i++)
		part2[vertexs2[i]->info.syscall_no].push_back(vertexs2[i]);

	// TODO: generate all subsets with k elements, where k is the
	// number of elements of a cell from the second partition

	/*
	 * Not necessary, we'll consider single vertex graphs as trivial
	 * cases of specifications
	 */
	return result;
}

/*
 * Determines the minimal contrast subgraph set of the first
 * graph with respect to the second graph given as parameter
 */
std::vector<Graph*> minimal_contrast_subgraph_set(Graph *graph_positive, Graph *graph_negative)
{
	unsigned int i, j;
	std::vector<Graph*> contr_edge   = minimal_contrast_edge_sets(graph_positive, graph_negative);
	std::vector<Graph*> contr_vertex = minimal_contrast_vertex_sets(graph_positive, graph_negative);
	std::vector<Graph*> result;

	contr_edge.insert(contr_edge.end(), contr_vertex.begin(), contr_vertex.end());
	std::vector<bool> mark(contr_edge.size(), false);
	// search and mark duplicate graphs
	for(i = 0; i < contr_edge.size(); i++) {
		for(j = i + 1; j < contr_edge.size(); j++) {
			if(!mark[j] && contr_edge[i]->equals(contr_edge[j])) {
				mark[j] = true;
			}
		}
	}
	// search and mark supergraphs
	for(i = 0; i < contr_edge.size(); i++) {
		for(j = 0; j < contr_edge.size(); j++) {
			if(!mark[j] && i != j &&
					contr_edge[j]->is_subgraph(contr_edge[i])) {
				mark[i] = true;
				break;
			}
		}
	}
	// delete supergraphs from set
	for(i = 0; i < contr_edge.size(); i++) {
		if(mark[i])
			delete contr_edge[i];
		else
			result.push_back(contr_edge[i]);
	}
	return result;
}
