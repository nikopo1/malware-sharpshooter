#include "malspec.h"
#include <map>
#include <iostream>

/*
 * All the edges have equal weights, so a simple BFS will be enough for
 * extracting the minimal transversal tree
 */
std::vector<Graph*> minimal_transversal(Graph* graph)
{
	unsigned int i, j;
	std::vector< Graph* > result;
	std::vector< Vertex* > vertexs = graph->getVertexs();
	Graph *p;
	std::vector< std::pair<Vertex*, Vertex*> > transversal;
	for(i = 0; i < vertexs.size(); i++)
		vertexs[i]->set_visited(false);

	for(i = 0; i < vertexs.size(); i++) {
		if(!vertexs[i]->is_visited()) {
			transversal.clear();
			graph->bfs_transversal(vertexs[i], transversal);
			if(transversal.size() > 0) {
				p = graph->vertex_copy();
				for(j = 0; j < transversal.size(); j++)
					p->add_edge(transversal[j].first, transversal[j].second);
				p->clear_isolated_vertexs();
				result.push_back(p);
			}
		}
	}
	return result;
}

/*
 * Returns the minimal contrast edge set of graph1 with respect to
 * graph2.
 */
std::vector<Graph*> minimal_contrast_edge_sets(Graph *graph1, Graph *graph2)
{
	unsigned int i;
	Graph *complement;
	std::vector<int> coresp(graph1->getVertexs().size(), VERTEX_NONE);
	std::vector<int> aux;
	std::vector<Graph*> min_trans;
	std::vector<Graph*> result;
	/* determine the maximal common edge set between graph1 and
	 * graph2 */
	if(graph1->getVertexs().size() < graph2->getVertexs().size()) {
		coresp = graph1->maximal_common_edge_set(graph2);
	} else {
		aux = graph2->maximal_common_edge_set(graph1);
		/* we have to reverse the matching nodes vector */
		for(i = 0; i < aux.size(); i++)
			if(aux[i] != VERTEX_NONE)
				coresp[aux[i]] = i;
	}

	/* compute complement of graph1 with respect to the maximal
	 * common edge set */
	complement = graph1->subgraph_complement(coresp);

	/* compute the minimal traversal of the complement, which will
	 * be the minimal contrast edge set */
	result = minimal_transversal(complement);
	delete complement;
	return result;
}


std::vector<Graph*> minimal_contrast_vertex_sets(Graph *graph1, Graph *graph2)
{
	unsigned int i;
	std::vector<Graph*> result;
	std::vector<Vertex*> vertexs1 = graph1->getVertexs();
	std::vector<Vertex*> vertexs2 = graph2->getVertexs();
	std::map< int, std::vector<Vertex*> > part1;
	std::map< int, std::vector<Vertex*> > part2;

	for(i = 0; i < vertexs1.size(); i++)
		part1[vertexs1[i]->info.syscall_no].push_back(vertexs1[i]);

	for(i = 0; i < vertexs2.size(); i++)
		part2[vertexs2[i]->info.syscall_no].push_back(vertexs2[i]);

	// TODO: generate all subsets with k elements, where k is the
	// number of elements of a cell from the second partition

	/*
	 * Not necessary, we'll consider single vertex graphs as trivial
	 * cases of specifications
	 */
	return result;
}

/*
 * Determines the minimal contrast subgraph set of the first
 * graph with respect to the second graph given as parameter
 */
std::vector<Graph*> minimal_contrast_subgraph_set(Graph *graph_positive, Graph *graph_negative)
{
	unsigned int i, j;
	std::vector<Graph*> contr_edge   = minimal_contrast_edge_sets(graph_positive, graph_negative);
	/*
	std::vector<Graph*> contr_vertex = minimal_contrast_vertex_sets(graph_positive, graph_negative);
	std::vector<Graph*> result;
	
	contr_edge.insert(contr_edge.end(), contr_vertex.begin(), contr_vertex.end());
	std::vector<bool> mark(contr_edge.size(), false);
	// search and mark duplicate graphs
	for(i = 0; i < contr_edge.size(); i++) {
		for(j = i + 1; j < contr_edge.size(); j++) {
			if(!mark[j] && contr_edge[i]->equals(contr_edge[j])) {
				mark[j] = true;
			}
		}
	}
	// search and mark supergraphs
	for(i = 0; i < contr_edge.size(); i++) {
		for(j = 0; j < contr_edge.size(); j++) {
			if(!mark[j] && i != j &&
					contr_edge[j]->is_subgraph(contr_edge[i])) {
				mark[i] = true;
				break;
			}
		}
	}
	// delete supergraphs from set
	for(i = 0; i < contr_edge.size(); i++) {
		if(mark[i])
			delete contr_edge[i];
		else
			result.push_back(contr_edge[i]);
	}
	return result;
	*/
	return contr_edge;
}

std::vector<Graph*> maximal_union(const std::vector<Graph*> &set1,
		const std::vector<Graph*> &set2) {
	
	unsigned int i, j;
	std::vector<Graph*> result;
	std::vector<bool> mark_set1(set1.size(), false);
	std::vector<bool> mark_set2(set2.size(), false);

	for(i = 0; i < set1.size(); i++) {
		for(j = 0; j < set2.size(); j++) {
			if(set1[i]->is_subgraph(set2[j]))
				mark_set1[i] = true;
			else if(set2[j]->is_subgraph(set1[j]))
				mark_set2[j] = true;
		}
	}
	for(i = 0; i < set1.size(); i++)
		if(!mark_set1[i])
			result.push_back(set1[i]);
		else
			delete set1[i];
	for(i = 0; i < set2.size(); i++)
		if(!mark_set2[i])
			result.push_back(set2[i]);
		else
			delete set2[i];
	return result;
}

/*
 * Runs the malspec-mining algorithm for the malware and benign programs
 * (the executables pathfiles are in the vectors) given as parameters.
 */
std::vector<Graph*> malspec_mining(GraphBuilder &gb,
		const std::string &malware_program,
		const std::vector<std::string> &benign_programs)
{
	unsigned int i;
	std::vector<Graph*> result;
	std::vector<Graph*> mcs;
	Graph* malware_graph = gb.build_graph(malware_program.c_str());
	std::cout<<"Malware graph:"<<std::endl;
	std::cout<<*malware_graph<<std::endl;
	Graph* benign_graph = NULL;

	for(i = 0; i < benign_programs.size(); i++) {
		std::cout<<"Analyzing malware vs "<<benign_programs[i]<<std::endl;
		benign_graph = gb.build_graph(benign_programs[i].c_str());
		std::cout<<"Benign graph:"<<std::endl;
		std::cout<<*benign_graph<<std::endl;
		mcs = minimal_contrast_subgraph_set(malware_graph, benign_graph);
		/* maximal union with other findings in set */
		result = maximal_union(mcs, result);
		delete benign_graph;
	}

	delete malware_graph;
	return result;
}
