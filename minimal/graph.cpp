#include "graph.h"
#include <algorithm>
#include <queue>

Graph::Graph() {
}

Graph::Graph(syscall_t* trace, int length) {
	for(int i = 0; i < length; i++) {
		addVertex(new Vertex(trace[i]));
	}
}

Graph::~Graph() {
	for(unsigned int i = 0; i < vertexs.size(); i++)
		delete vertexs[i];
}

void Graph::generateVertexes(syscall_t* trace, int length) {
	for(int i = 0; i < length; i++) {
		addVertex(new Vertex(trace[i]));
	}
}

void Graph::addVertex(Vertex *node) {
	edges.push_back(std::vector< Vertex* >());
	node->index = vertexs.size();
	vertexs.push_back(node);
}

bool Graph::hasVertex(Vertex *node) {
	return vertexs[node->index]->info.syscall_no == node->info.syscall_no;
}

void Graph::addEdge(Vertex *from, Vertex *to) {
	if(from->index >= vertexs.size() || to->index >= vertexs.size()) {
		std::cout<<"Error adding edge from "<<from->index<<" to ";
		std::cout<<to->index<<std::endl;
		return;
	}
	edges[from->index].push_back(vertexs[to->index]);
}

void Graph::addEdge(unsigned int from, unsigned int to) {
	if(from >= vertexs.size() || to >= vertexs.size()) {
		std::cout<<"Error adding edge from "<<from<<" to ";
		std::cout<<to<<std::endl;
		return;
	}
	edges[from].push_back(vertexs[to]);
}

bool Graph::hasEdge(Vertex *from, Vertex *to) {
	for(unsigned int i = 0; i < edges[from->index].size(); i++)
		if(edges[from->index][i]->index == to->index)
			return true;
	return false;
}

void Graph::clear_isolated_vertexs(void) {
	unsigned int i, j;
	std::vector<Vertex*>::iterator vit = vertexs.begin();
	std::vector< std::vector<Vertex*> >::iterator eit = edges.begin();
	for(i = 0; i < vertexs.size(); i++)
		vertexs[i]->setVisited(false);
	// mark all the vertexs with edges
	for(i = 0; i < edges.size(); i++)
		if(edges[i].size() > 0)
			vertexs[i]->setVisited(true);
	for(i = 0; i < vertexs.size(); i++)
		for(j = 0; j < edges[i].size(); j++)
			edges[i][j]->setVisited(true);
	// clear vertexs with no edges
	for(vit = vertexs.begin(); vit != vertexs.end();) {
		if(!(*vit)->isVisited()) {
			edges.erase(edges.begin() + (int)(vit-vertexs.begin()));
			vit = vertexs.erase(vit);
		} else {
			++vit;
		}
	}
	for(i = 0; i < vertexs.size(); i++) {
		vertexs[i]->index = i;
	}
}

std::vector< Vertex* > Graph::getVertexs() {
	return vertexs;
}

std::vector< std::pair<Vertex*, Vertex*> > Graph::getEdges() const {
	std::vector< std::pair<Vertex*, Vertex*> > result;
	for(unsigned int i = 0; i < vertexs.size(); i++)
		for(unsigned int j = 0; j < edges[i].size(); j++)
			result.push_back(std::pair<Vertex*, Vertex*>(vertexs[i], edges[i][j]));
	return result;
}

std::vector< Vertex* > Graph::getNeighbours(unsigned int index) {
	if(index >= edges.size()) {
		std::cout<<"Invalid neighbour request: "<<index<<", size=";
		std::cout<<edges.size()<<std::endl;
		return std::vector< Vertex* >();
	}
	return edges[index];
}

std::vector< Vertex* > Graph::getNeighbours(Vertex *vertex) {
	for(unsigned int i = 0; i < vertexs.size(); i++)
		if(vertexs[i]->index == vertex->index)
			return edges[i];
	return std::vector< Vertex* >();
}

std::ostream& operator<<(std::ostream& stream, const Graph& graph) {
	std::vector< Vertex* >::const_iterator vit;
	std::vector< std::pair<Vertex* ,Vertex*> >::const_iterator eit;
	const std::vector< std::pair<Vertex*, Vertex*> > edges = graph.getEdges();
	/* print vertexes */
	stream<<"V={ ";
	for(vit = graph.vertexs.begin(); vit != graph.vertexs.end(); ++vit)
		stream<<"("<<(*vit)->index<<" sc="<<(*vit)->info.syscall_no<<"), ";
	stream<<"};"<<std::endl;
	/* print edges */
	stream<<"E={ ";
	for(eit = edges.begin(); eit != edges.end(); ++eit)
		stream<<"("<<eit->first->index<<", "<<eit->second->index<<"), ";
	stream<<"};"<<std::endl;
	return stream;
}

int Graph::generateDepEdges(void) {
	int i, j, n = vertexs.size();
	for(i = 0; i < n; i++) {
		for(j = i + 1; j < n; j++) {
			if(vertexs[j]->dependsOn(vertexs[i])) {
				edges[i].push_back(vertexs[j]);
			}
			if(vertexs[j]->closesVertex(vertexs[i]))
				break;
		}
	}
	return 0;
}

inline unsigned int refine_marcs(std::vector<bool> &marcs, unsigned int i,
		unsigned int j,
		const std::vector< std::pair<Vertex* ,Vertex*> > &edges1,
		const std::vector< std::pair<Vertex* ,Vertex*> > &edges2) {
	unsigned int r, s, count = 0;
	bool row_false;
	for(r = 0; r < edges1.size(); r++) {
		row_false = true;
		for(s = 0; s < edges2.size(); s++) {
			if(edges1[r].first->index == i && edges2[s].first->index != j)
				marcs[r * edges2.size() + s] = false;
			if(edges1[r].second->index == i && edges2[s].second->index != j)
				marcs[r * edges2.size() + s] = false;
			if(marcs[r * edges2.size() + s] == true)
				row_false = false;
		}
		if(!row_false)
			count++;
	}
	return count;
}

inline unsigned int refine_marcs_ignore_node(std::vector<bool> &marcs,
		unsigned int i,
		const std::vector< std::pair<Vertex* ,Vertex*> > &edges1,
		const std::vector< std::pair<Vertex* ,Vertex*> > &edges2) {
	unsigned int r, s, count = 0;
	bool row_false;
	/* if node i isn't used any more, then we'll lose all posible
	 * matches edges containing node i */
	for(r = 0; r < edges1.size(); r++)
		for(s = 0; s < edges2.size(); s++)
			if(edges1[r].first->index == i ||
					edges1[r].second->index == i)
				marcs[r * edges2.size() + s] = false;

	for(r = 0; r < edges1.size(); r++) {
		row_false = true;
		for(s = 0; s < edges2.size(); s++)
			if(marcs[r * edges2.size() + s] ==true)
				row_false = false;
		if(!row_false)
			count++;
	}
	return count;
}

void print_marcs(std::vector<bool> &marcs, unsigned int ne1, unsigned int ne2) {
	for(unsigned int i = 0; i < ne1; i++) {
		for(unsigned int j = 0; j < ne2; j++) {
			std::cout<<marcs[i * ne2 + j]<<" ";
		}
		std::cout<<std::endl;
	}
}

void maxCommonEdgeSetBkt(unsigned int idx, std::vector<bool> marcs,
		std::vector<bool> &used_val,
		const std::vector<Vertex*> &nodes1,
		const std::vector<Vertex*> &nodes2,
		const std::vector< std::pair<Vertex* ,Vertex*> > &edges1,
		const std::vector< std::pair<Vertex* ,Vertex*> > &edges2,
		std::vector<int> &common,
		std::vector<int> &solution,
		unsigned int &bestarcsleft) {
	
	unsigned int i, j, arcsleft;
	std::vector<bool> marcs_new;
	/* try to not use this node in the matching process */
	/* VERTEX_NONE means that a correspondence for this node will
	 * not be searched for */
	common[idx] = VERTEX_NONE;
	marcs_new = marcs;
	arcsleft = refine_marcs_ignore_node(marcs_new, idx, edges1, edges2);
	if(arcsleft > bestarcsleft) {
		if(idx == nodes1.size() - 1) {
			bestarcsleft = arcsleft;
			solution = common;
			for(i = 0; i < common.size(); i++)
				std::cout<<common[i]<<" ";
			std::cout<<std::endl;
		} else {
			maxCommonEdgeSetBkt(idx + 1, marcs_new, used_val,
					nodes1, nodes2,
					edges1, edges2,
					common, solution, bestarcsleft);
		}
	}
	/* try to find a matching node */
	for(j = 0; j < nodes2.size(); j++) {
		/* if the node was previously matched to another node,
		 * then don't reuse it */
		if(used_val[j] == true)
			continue;
		/* both nodes have to be labeled with the same system call
		 * number */
		if(nodes1[idx]->info.syscall_no == nodes2[j]->info.syscall_no) {
			/* set value in partial solution */
			common[idx] = j;
			/* refine @marcs, marcs is passed by copy */
			marcs_new = marcs;
			arcsleft = refine_marcs(marcs_new, idx, j, edges1, edges2);
			/* continue only if a better solution is
			 * possible */
			if(arcsleft > bestarcsleft) {
				if(idx == nodes1.size() - 1) {
					bestarcsleft = arcsleft;
					solution = common;
					for(i = 0; i < common.size(); i++)
						std::cout<<common[i]<<" ";
					std::cout<<std::endl;
				} else {
					used_val[j] = true;
					maxCommonEdgeSetBkt(idx + 1, marcs_new,
							used_val,
							nodes1, nodes2,
							edges1, edges2,
							common, solution,
							bestarcsleft);
					used_val[j] = false;
				}
			}
		}
	}
}

/*
 * Assumes that _this_ is the smaller graph and computes the maximal
 * common edge set between _this_ and graph.
 */
std::vector<int> Graph::maximalCommonEdgeSet(Graph *graph) {

	unsigned int bestarcsleft = 0;
	std::vector<int> common(vertexs.size(), -1);
	std::vector<int> solution(vertexs.size(), -1);
	std::vector<bool> marcs(getEdges().size() * graph->getEdges().size(), true);
	std::vector<bool> used_val(graph->getEdges().size(), false);

	maxCommonEdgeSetBkt(0, marcs, used_val,
			vertexs, graph->getVertexs(),
			getEdges(), graph->getEdges(),
			common, solution, bestarcsleft);
	return solution;
}

/*
 * Computes the complement of _this_ graph and the nodes from the
 * vertex_subset where vertex_subset[i] = x means that node i in _this_
 * graph correspondes to node x in the other graph.
 */
Graph* Graph::subgraphComplement(std::vector<int> &vertex_subset) {

	Graph* result = new Graph();
	std::vector< std::pair<Vertex*, Vertex*> > graph_edges = getEdges();
	for(unsigned int i = 0; i < vertex_subset.size(); i++)
		if(vertex_subset[i] == VERTEX_NONE)
			result->addVertex(new Vertex(*vertexs[i]));

	result->generateDepEdges();
	return result;
}

void Graph::bfs_transversal(Vertex *start, std::vector< std::pair<Vertex*, Vertex*> > &transversal) {
	Vertex* current;
	std::queue< Vertex* > q;
	std::vector< Vertex* > adj;
	unsigned int i;

	q.push(start);
	start->setVisited(true);

	while(!q.empty()) {
		current = q.front();
		q.pop();
		adj = getNeighbours(current);
		for(i = 0; i < adj.size(); i++) {
			if(!adj[i]->isVisited()) {
				adj[i]->setVisited(true);
				transversal.push_back(std::pair<Vertex*, Vertex*>(current, adj[i]));
				q.push(adj[i]);
			}
		}
	}
}

/*
 * All the edges have equal weights, so a simple BFS will be enough for
 * extracting the minimal transversal tree
 */
std::vector<Graph*> Graph::minimalTransversal(Graph* graph) {
	unsigned int i, j;
	std::vector< Graph* > result;
	std::vector< Vertex* > vertexs = graph->getVertexs();
	Graph *p;
	std::vector< std::pair<Vertex*, Vertex*> > transversal;
	for(i = 0; i < vertexs.size(); i++)
		vertexs[i]->setVisited(false);

	for(i = 0; i < vertexs.size(); i++) {
		if(!vertexs[i]->isVisited()) {
			transversal.clear();
			graph->bfs_transversal(vertexs[i], transversal);
			if(transversal.size() > 0) {
				p = graph->vertex_copy();
				for(j = 0; j < transversal.size(); j++)
					p->addEdge(transversal[j].first, transversal[j].second);
				p->clear_isolated_vertexs();
				result.push_back(p);
			}
		}
	}
	return result;
}

/*
 * Returns the minimal contrast edge set of graph1 with respect to
 * graph2.
 */
std::vector<Graph*> Graph::minimalContrastEdgeSets(Graph *graph1, Graph *graph2) {
	Graph *complement;
	std::vector<int> coresp;
	std::vector<Graph*> min_trans;
	std::vector<Graph*> result;
	/* determine the maximal common edge set between graph1 and
	 * graph2 */
	coresp = graph1->maximalCommonEdgeSet(graph2);

	/* compute complement of graph1 with respect to the maximal
	 * common edge set */
	complement = graph1->subgraphComplement(coresp);

	/* compute the minimal traversal of the complement, which will
	 * be the minimal contrast edge set */
	result = complement->minimalTransversal(complement);

	//return edge sets;
	return result;
}


std::vector<Graph*> Graph::minimalContrastVertexSets(Graph *graph1, Graph *graph2) {

	std::vector<Graph*> result;
	//std::map< int, std::vector<Vertex*> > partitions;
	/*
	 * Not necessary, we'll consider single vertex graphs as trivial
	 * cases of specifications
	 */
	return result;
}

/*
 * Determines the minimal contrast subgraph set of the first
 * graph with respect to the second graph given as parameter
 */
std::vector<Graph*> Graph::minimalContrastSubgraphSet(Graph *graph_positive, Graph *graph_negative) {

	std::vector<Graph*> contr_edge   = Graph::minimalContrastEdgeSets(graph_positive, graph_negative);
	std::vector<Graph*> contr_vertex = Graph::minimalContrastVertexSets(graph_positive, graph_negative);
	// TODO 1: remove graphs which are supergraphs of others in
	// the contrast edge set

	// TODO 2: remove contrast vertex sets which are subgraphs of
	// contrast vertex sets

	return contr_edge;
}

/*
 * Appends the vertexs and edges of the other graph to this graph, thus
 * the union.
 */
void Graph::append_graph(Graph* other) {
	unsigned int i, j, old_size;
	std::vector< Vertex* > v_other = other->getVertexs();
	std::vector< Vertex* > adj;
	old_size = vertexs.size();
	for(i = 0; i < v_other.size(); i++)
		addVertex(new Vertex(*v_other[i]));
	for(i = 0; i < v_other.size(); i++) {
		adj = other->getNeighbours(v_other[i]);
		/* must add offset for other graph neighbours */
		for(j = 0; j < adj.size(); j++)
			addEdge(i + old_size, adj[j]->index + old_size);
	}
}

/*
 * Makes a vertex copy graph of _this_ graph.
 */
Graph* Graph::vertex_copy(void) {
	unsigned int i;
	Graph *result = new Graph();
	for(i = 0; i < vertexs.size(); i++)
		result->addVertex(new Vertex(*vertexs[i]));
	return result;
}

/*
 * Considering that the vertexs from graph1 and graph2 are disjoint
 * sets, do the graph union.
 */
Graph* Graph::union_graph(Graph* graph1, Graph* graph2) {
	Graph* result = new Graph();
	unsigned int i, j;
	std::vector< Vertex* > v1 = graph1->getVertexs();
	std::vector< Vertex* > e1;

	/* copying graph1 to result */
	for(i = 0; i < v1.size(); i++) {
		result->addVertex(new Vertex(*v1[i]));
	}
	for(i = 0; i < v1.size(); i++) {
		e1 = graph1->getNeighbours(v1[i]);
		for(j = 0; j < e1.size(); j++) {
			result->addEdge(v1[i], e1[j]);
		}
	}
	result->append_graph(graph2);
	return result;
}
