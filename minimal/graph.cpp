#include "graph.h"
#include <algorithm>
#include <queue>

bool Graph::debug = true;

Graph::Graph() { }

Graph::Graph(syscall_t* trace, int length)
{
	for(int i = 0; i < length; i++) {
		add_vertex(new Vertex(trace[i]));
	}
}

Graph::~Graph()
{
	for(unsigned int i = 0; i < vertexs.size(); i++)
		delete vertexs[i];
}

void Graph::add_vertex(Vertex *node)
{
	edges.push_back(std::vector< Vertex* >());
	node->index = vertexs.size();
	vertexs.push_back(node);
}

bool Graph::has_vertex(Vertex *node)
{
	return vertexs[node->index]->info.syscall_no == node->info.syscall_no;
}

bool Graph::remove_vertex(Vertex *node)
{
	bool found = false;
	unsigned int i, j;
	/* delete edges to @node */
	for(i = 0; i < edges.size(); i++) {
		for(j = 0; j < edges[i].size(); j++) {
			if(edges[i][j] == node) {
				edges[i].erase(edges[i].begin() + j);
				break;
			}
		}
	}
	/* delete @node */
	for(i = 0; i < vertexs.size(); i++) {
		if(vertexs[i] == node) {
			vertexs.erase(vertexs.begin() + i);
			edges.erase(edges.begin() + i);
			found = true;
			break;
		}
	}
	/* restore indexing */
	for(i = 0; i < vertexs.size(); i++)
		vertexs[i]->index = i;
	return found;
}

void Graph::add_edge(Vertex *from, Vertex *to)
{
	if(from->index >= vertexs.size() || to->index >= vertexs.size()) {
		std::cout<<"Error adding edge from "<<from->index<<" to ";
		std::cout<<to->index<<std::endl;
		return;
	}
	edges[from->index].push_back(vertexs[to->index]);
}

void Graph::add_edge(unsigned int from, unsigned int to)
{
	if(from >= vertexs.size() || to >= vertexs.size()) {
		std::cout<<"Error adding edge from "<<from<<" to ";
		std::cout<<to<<std::endl;
		return;
	}
	edges[from].push_back(vertexs[to]);
}

bool Graph::has_edge(Vertex *from, Vertex *to)
{
	for(unsigned int i = 0; i < edges[from->index].size(); i++)
		if(edges[from->index][i]->index == to->index)
			return true;
	return false;
}

/*
 * Tests equality between _this_ and the other graph. Uses the maximal
 * common edge set algorithm to determine the vertexs corespondence so
 * this is an expensive operation.
 */
bool Graph::equals(const Graph *other)
{
	unsigned int i, j, index1, index2;
	std::vector<int> coresp;
	/* graphs with different number of nodes can't be equal */
	if(vertexs.size() != other->vertexs.size())
		return false;
	/* if a node doesn't have a corespondent, then graphs can't be
	 * equal */
	coresp = maximal_common_edge_set(other);
	for(i = 0; i < coresp.size(); i++)
		if(coresp[i] == -1)
			return false;
	/* same vertexs, now check for equivalent edges */
	for(i = 0; i < coresp.size(); i++) {
		if(edges[i].size() != other->edges[coresp[i]].size())
			return false;
		for(j = 0; j < edges[i].size(); j++) {
			index1 = edges[i][j]->index;
			index2 = other->edges[coresp[i]][j]->index;
			if((unsigned int)coresp[index1] != index2)
				return false;
		}
	}
	return true;
}
std::vector< Vertex* > Graph::getVertexs() const
{
	return vertexs;
}

std::vector< std::pair<Vertex*, Vertex*> > Graph::getEdges() const
{
	std::vector< std::pair<Vertex*, Vertex*> > result;
	for(unsigned int i = 0; i < vertexs.size(); i++)
		for(unsigned int j = 0; j < edges[i].size(); j++)
			result.push_back(std::pair<Vertex*, Vertex*>(vertexs[i], edges[i][j]));
	return result;
}

std::vector< Vertex* > Graph::getNeighbours(unsigned int index)
{
	if(index >= edges.size()) {
		std::cout<<"Invalid neighbour request: "<<index<<", size=";
		std::cout<<edges.size()<<std::endl;
		return std::vector< Vertex* >();
	}
	return edges[index];
}

std::vector< Vertex* > Graph::getNeighbours(Vertex *vertex)
{
	for(unsigned int i = 0; i < vertexs.size(); i++)
		if(vertexs[i]->index == vertex->index)
			return edges[i];
	return std::vector< Vertex* >();
}

std::ostream& operator<<(std::ostream& stream, const Graph& graph)
{
	std::vector< Vertex* >::const_iterator vit;
	std::vector< std::pair<Vertex* ,Vertex*> >::const_iterator eit;
	const std::vector< std::pair<Vertex*, Vertex*> > edges = graph.getEdges();
	/* print vertexes */
	stream<<"V["<<graph.vertexs.size()<<"]={ ";
	for(vit = graph.vertexs.begin(); vit != graph.vertexs.end(); ++vit)
		stream<<"("<<(*vit)->index<<" sc="<<(*vit)->info.syscall_no<<"), ";
	stream<<"};"<<std::endl;
	/* print edges */
	stream<<"E["<<edges.size()<<"]={ ";
	for(eit = edges.begin(); eit != edges.end(); ++eit)
		stream<<"("<<eit->first->index<<", "<<eit->second->index<<"), ";
	stream<<"};"<<std::endl;
	return stream;
}

void Graph::generate_vertexs(syscall_t* trace, int length)
{
	for(int i = 0; i < length; i++) {
		add_vertex(new Vertex(trace[i]));
	}
}

int Graph::generate_edges(void)
{
	int i, j, n = vertexs.size();
	for(i = 0; i < n; i++) {
		for(j = i + 1; j < n; j++) {
			if(vertexs[j]->depends_on(vertexs[i])) {
				edges[i].push_back(vertexs[j]);
			}
			if(vertexs[j]->closes_vertex(vertexs[i]))
				break;
		}
	}
	return 0;
}

bool Graph::same_edges(Vertex* v1, Vertex* v2)
{
	unsigned int i, j;
	bool found, e1, e2;
	/* check out-edges */
	if(edges[v1->index].size() != edges[v2->index].size())
		return false;
	for(i = 0; i < edges[v1->index].size(); i++) {
		found = false;
		for(j = 0; j < edges[v1->index].size(); j++) {
			if(edges[v1->index][i] == edges[v2->index][j])
				found = true;
		}
		if(!found)
			return false;
	}
	/* check in-edges */
	for(i = 0; i < edges.size(); i++) {
		if(vertexs[i] != v1 && vertexs[i] != v2) {
			e1 = false;
			e2 = false;
			for(j = 0; j < edges[i].size(); j++) {
				if(edges[i][j] == v1)
					e1 = true;
				if(edges[i][j] == v2)
					e2 = true;
			}
			if(e1 != e2)
				return false;
		}
	}
	return true;
}

void Graph::aggregate_vertexs(void)
{
	unsigned int i, j;
	Vertex *first;
	for(i = 0; i < vertexs.size(); i++) {
		// find first child node
		for(j = i+1; j < vertexs.size(); j++) {
			if(has_edge(vertexs[i], vertexs[j])) {
				first = vertexs[j++];
				break;
			}
		}
		while(j < vertexs.size()) {
			if(has_edge(vertexs[i], vertexs[j])) {
				if(first->info.syscall_no == vertexs[j]->info.syscall_no &&
						same_edges(first, vertexs[j])) {
					/*
						std::cout<<"Removed\n";
						std::cout<<vertexs[i]->index<<", sc="<<vertexs[i]->info.syscall_no;
						std::cout<<std::endl;
						std::cout<<first->index<<", sc="<<first->info.syscall_no;
						std::cout<<std::endl;
						std::cout<<vertexs[j]->index<<", sc="<<vertexs[j]->info.syscall_no;
						std::cout<<std::endl;
					*/
					remove_vertex(vertexs[j]);
				}
				else
					first = vertexs[j++];
			} else {
				j++;
			}
		}
	}
}

void Graph::clear_isolated_vertexs(void)
{
	unsigned int i, j;
	std::vector<Vertex*>::iterator vit = vertexs.begin();
	std::vector< std::vector<Vertex*> >::iterator eit = edges.begin();
	for(i = 0; i < vertexs.size(); i++)
		vertexs[i]->set_visited(false);
	// mark all the vertexs with edges
	for(i = 0; i < edges.size(); i++)
		if(edges[i].size() > 0)
			vertexs[i]->set_visited(true);
	for(i = 0; i < vertexs.size(); i++)
		for(j = 0; j < edges[i].size(); j++)
			edges[i][j]->set_visited(true);
	// clear vertexs with no edges
	for(vit = vertexs.begin(); vit != vertexs.end();) {
		if(!(*vit)->is_visited()) {
			edges.erase(edges.begin() + (int)(vit-vertexs.begin()));
			vit = vertexs.erase(vit);
		} else {
			++vit;
		}
	}
	for(i = 0; i < vertexs.size(); i++) {
		vertexs[i]->index = i;
	}
}

inline unsigned int refine_marcs(std::vector<bool> &marcs, unsigned int i,
		unsigned int j,
		const std::vector< std::pair<Vertex* ,Vertex*> > &edges1,
		const std::vector< std::pair<Vertex* ,Vertex*> > &edges2)
{
	unsigned int r, s, count = 0;
	bool row_false;
	for(r = 0; r < edges1.size(); r++) {
		row_false = true;
		for(s = 0; s < edges2.size(); s++) {
			if(edges1[r].first->index == i && edges2[s].first->index != j)
				marcs[r * edges2.size() + s] = false;
			if(edges1[r].second->index == i && edges2[s].second->index != j)
				marcs[r * edges2.size() + s] = false;
			if(marcs[r * edges2.size() + s] == true)
				row_false = false;
		}
		if(!row_false)
			count++;
	}
	return count;
}

inline unsigned int refine_marcs_ignore_node(std::vector<bool> &marcs,
		unsigned int i,
		const std::vector< std::pair<Vertex* ,Vertex*> > &edges1,
		const std::vector< std::pair<Vertex* ,Vertex*> > &edges2)
{
	unsigned int r, s, count = 0;
	bool row_false;
	/* if node i isn't used any more, then we'll lose all posible
	 * matches edges containing node i */
	for(r = 0; r < edges1.size(); r++)
		for(s = 0; s < edges2.size(); s++)
			if(edges1[r].first->index == i ||
					edges1[r].second->index == i)
				marcs[r * edges2.size() + s] = false;

	for(r = 0; r < edges1.size(); r++) {
		row_false = true;
		for(s = 0; s < edges2.size(); s++)
			if(marcs[r * edges2.size() + s] ==true)
				row_false = false;
		if(!row_false)
			count++;
	}
	return count;
}

void print_marcs(std::vector<bool> &marcs, unsigned int ne1, unsigned int ne2)
{
	for(unsigned int i = 0; i < ne1; i++) {
		for(unsigned int j = 0; j < ne2; j++) {
			std::cout<<marcs[i * ne2 + j]<<" ";
		}
		std::cout<<std::endl;
	}
}

void max_common_edge_set_bkt(unsigned int idx, std::vector<bool> marcs,
		std::vector<bool> &used_val,
		const std::vector<Vertex*> &nodes1,
		const std::vector<Vertex*> &nodes2,
		const std::vector< std::pair<Vertex* ,Vertex*> > &edges1,
		const std::vector< std::pair<Vertex* ,Vertex*> > &edges2,
		std::vector<int> &common,
		std::vector<int> &solution,
		unsigned int &bestarcsleft)
{
	unsigned int i, j, arcsleft;
	std::vector<bool> marcs_new;
	/* try to not use this node in the matching process */
	/* VERTEX_NONE means that a correspondence for this node will
	 * not be searched for */
	common[idx] = VERTEX_NONE;
	marcs_new = marcs;
	arcsleft = refine_marcs_ignore_node(marcs_new, idx, edges1, edges2);

	// leftover from debug check
	/*	
	if(idx == nodes1.size() - 1)
	{
		for(i = 0; i < common.size(); i++)
			std::cout<<common[i]<<" ";
		std::cout<<std::endl;
	}
	
	for(i = 0; i < used_val.size(); i++)
		std::cout<<"used_val["<<i<<"]="<<used_val[i]<<" ";
	std::cout<<std::endl;
	*/

	if(arcsleft > bestarcsleft) {
		if(idx == nodes1.size() - 1) {
			bestarcsleft = arcsleft;
			solution = common;
			if(Graph::debug) {
				for(i = 0; i < common.size(); i++)
					std::cout<<common[i]<<" ";
				std::cout<<std::endl;
			}
		} else {
			max_common_edge_set_bkt(idx + 1, marcs_new, used_val,
					nodes1, nodes2,
					edges1, edges2,
					common, solution, bestarcsleft);
		}
	}
	/* try to find a matching node */
	for(j = 0; j < nodes2.size(); j++) {
		/* if the node was previously matched to another node,
		 * then don't reuse it */
		if(used_val[j] == true)
			continue;
		/* both nodes have to be labeled with the same system call
		 * number */
		if(nodes1[idx]->info.syscall_no == nodes2[j]->info.syscall_no) {
			/* set value in partial solution */
			common[idx] = j;
			used_val[j] = true;
			/* refine @marcs, marcs is passed by copy */
			marcs_new = marcs;
			arcsleft = refine_marcs(marcs_new, idx, j, edges1, edges2);
			/* continue only if a better solution is
			 * possible */
			if(arcsleft > bestarcsleft) {
				if(idx == nodes1.size() - 1) {
					bestarcsleft = arcsleft;
					solution = common;
					if(Graph::debug) {
						for(i = 0; i < common.size(); i++)
							std::cout<<common[i]<<" ";
						std::cout<<std::endl;
					}
				} else {
					max_common_edge_set_bkt(idx + 1, marcs_new,
							used_val,
							nodes1, nodes2,
							edges1, edges2,
							common, solution,
							bestarcsleft);
				}
			}
			used_val[j] = false;
			common[idx] = VERTEX_NONE;
		}
	}
}

/*
 * Assumes that _this_ is the smaller graph and computes the maximal
 * common edge set between _this_ and graph.
 */
std::vector<int> Graph::maximal_common_edge_set(const Graph *graph)
{
	unsigned int bestarcsleft = 0;
	std::vector<int> common(vertexs.size(), -1);
	std::vector<int> solution(vertexs.size(), -1);
	std::vector<bool> marcs(getEdges().size() * graph->getEdges().size(), true);
	std::vector<bool> used_val(graph->vertexs.size(), false);

	max_common_edge_set_bkt(0, marcs, used_val,
			vertexs, graph->getVertexs(),
			getEdges(), graph->getEdges(),
			common, solution, bestarcsleft);
	return solution;
}

/*
 * Computes the complement of _this_ graph and the nodes from the
 * vertex_subset where vertex_subset[i] = x means that node i in _this_
 * graph correspondes to node x in the other graph.
 */
Graph* Graph::subgraph_complement(std::vector<int> &vertex_subset)
{
	Graph* result = new Graph();
	std::vector< std::pair<Vertex*, Vertex*> > graph_edges = getEdges();
	for(unsigned int i = 0; i < vertex_subset.size(); i++)
		if(vertex_subset[i] == VERTEX_NONE)
			result->add_vertex(new Vertex(*vertexs[i]));

	result->generate_edges();
	return result;
}

bool Graph::is_subgraph(Graph* other)
{
	if(vertexs.size() > other->vertexs.size())
		return false;
	std::vector<int> coresp = maximal_common_edge_set(other);

	for(unsigned int i = 0; i < coresp.size(); i++)
		if(coresp[i] == -1)
			return false;
	return true;
}

void Graph::bfs_transversal(Vertex *start, std::vector< std::pair<Vertex*, Vertex*> > &transversal)
{
	Vertex* current;
	std::queue< Vertex* > q;
	std::vector< Vertex* > adj;
	unsigned int i;

	q.push(start);
	start->set_visited(true);

	while(!q.empty()) {
		current = q.front();
		q.pop();
		adj = getNeighbours(current);
		for(i = 0; i < adj.size(); i++) {
			if(!adj[i]->is_visited()) {
				adj[i]->set_visited(true);
				transversal.push_back(std::pair<Vertex*, Vertex*>(current, adj[i]));
				q.push(adj[i]);
			}
		}
	}
}

/*
 * Appends the vertexs and edges of the other graph to this graph, thus
 * the union.
 */
void Graph::append_graph(Graph* other)
{
	unsigned int i, j, old_size;
	std::vector< Vertex* > v_other = other->getVertexs();
	std::vector< Vertex* > adj;
	old_size = vertexs.size();
	for(i = 0; i < v_other.size(); i++)
		add_vertex(new Vertex(*v_other[i]));
	for(i = 0; i < v_other.size(); i++) {
		adj = other->getNeighbours(v_other[i]);
		/* must add offset for other graph neighbours */
		for(j = 0; j < adj.size(); j++)
			add_edge(i + old_size, adj[j]->index + old_size);
	}
}

/*
 * Makes a vertex copy graph of _this_ graph.
 */
Graph* Graph::vertex_copy(void)
{
	unsigned int i;
	Graph *result = new Graph();
	for(i = 0; i < vertexs.size(); i++)
		result->add_vertex(new Vertex(*vertexs[i]));
	return result;
}

/*
 * Considering that the vertexs from graph1 and graph2 are disjoint
 * sets, do the graph union.
 */
Graph* Graph::union_graph(Graph* graph1, Graph* graph2)
{
	Graph* result = new Graph();
	unsigned int i, j;
	std::vector< Vertex* > v1 = graph1->getVertexs();
	std::vector< Vertex* > e1;

	/* copying graph1 to result */
	for(i = 0; i < v1.size(); i++) {
		result->add_vertex(new Vertex(*v1[i]));
	}
	for(i = 0; i < v1.size(); i++) {
		e1 = graph1->getNeighbours(v1[i]);
		for(j = 0; j < e1.size(); j++) {
			result->add_edge(v1[i], e1[j]);
		}
	}
	result->append_graph(graph2);
	return result;
}
