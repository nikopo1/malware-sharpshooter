#include "graph.h"
#include <algorithm>

Graph::Graph() {
}

Graph::Graph(syscall_t* trace, int length) {
	for(int i = 0; i < length; i++) {
		addVertex(Vertex(i, trace[i]));
	}
}

Graph::~Graph() {
}

void Graph::generateVertexes(syscall_t* trace, int length) {
	for(int i = 0; i < length; i++) {
		addVertex(Vertex(i, trace[i]));
	}
}

void Graph::addVertex(const Vertex &node) {
	vertexs.push_back(node);
}

bool Graph::hasVertex(const Vertex &node) {
	return find(vertexs.begin(), vertexs.end(), node) != vertexs.end();
}

void Graph::addEdge(const Vertex &from, const Vertex &to) {
	edges.push_back(std::pair<Vertex, Vertex>(from, to));
}

bool Graph::hasEdge(const Vertex &from, const Vertex &to) {
	return find(edges.begin(), edges.end(),
			std::make_pair(from, to)) != edges.end();
}

bool Graph::hasEdge(const std::pair<Vertex, Vertex> &edge) {
	return find(edges.begin(), edges.end(), edge) != edges.end();
}

std::vector< Vertex > Graph::getVertexs() {
	return vertexs;
}

std::vector< std::pair<Vertex,Vertex> > Graph::getEdges() {
	return edges;
}

std::ostream& operator<<(std::ostream& stream, const Graph& graph) {
	std::vector< Vertex >::const_iterator vit;
	std::vector< std::pair<Vertex,Vertex> >::const_iterator eit;
	/* print vertexes */
	stream<<"V={ ";
	for(vit = graph.vertexs.begin(); vit != graph.vertexs.end(); ++vit)
		stream<<"("<<vit->index<<" sc="<<vit->info.syscall_no<<"), ";
	stream<<"};"<<std::endl;
	/* print edges */
	stream<<"E={ ";
	for(eit = graph.edges.begin(); eit != graph.edges.end(); ++eit)
		stream<<"("<<eit->first.index<<", "<<eit->second.index<<"), ";
	stream<<"};"<<std::endl;
	return stream;
}

int Graph::generateDepEdges(void) {
	int i, j, num = 0, n = vertexs.size();
	for(i = 0; i < n; i++) {
		for(j = i + 1; j < n; j++) {
			if(vertexs[j].dependsOn(vertexs[i])) {
				addEdge(vertexs[i], vertexs[j]);
				num++;
			}
		}
	}
	return 0;
}

inline unsigned int refine_marcs(std::vector<bool> &marcs, int i, int j,
		const std::vector< std::pair<Vertex,Vertex> > &edges1,
		const std::vector< std::pair<Vertex,Vertex> > &edges2) {
	unsigned int r, s, count = 0;
	bool row_false;
	for(r = 0; r < edges1.size(); r++) {
		row_false = true;
		for(s = 0; s < edges2.size(); s++) {
			if(edges1[r].first.index == i && edges2[s].first.index != j)
				marcs[r * edges2.size() + s] = false;
			if(edges1[r].second.index == i && edges2[s].second.index != j)
				marcs[r * edges2.size() + s] = false;
			if(marcs[r * edges2.size() + s] == true)
				row_false = false;
		}
		if(!row_false)
			count++;
	}
	return count;
}

inline unsigned int refine_marcs_ignore_node(std::vector<bool> &marcs, int i,
		const std::vector< std::pair<Vertex,Vertex> > &edges1,
		const std::vector< std::pair<Vertex,Vertex> > &edges2) {
	unsigned int r, s, count = 0;
	bool row_false;
	/* if node i isn't used any more, then we'll lose all posible
	 * matches edges containing node i */
	for(r = 0; r < edges1.size(); r++)
		for(s = 0; s < edges2.size(); s++)
			if(edges1[r].first.index == i ||
					edges1[r].second.index == i)
				marcs[r * edges2.size() + s] = false;

	for(r = 0; r < edges1.size(); r++) {
		row_false = true;
		for(s = 0; s < edges2.size(); s++)
			if(marcs[r * edges2.size() + s] ==true)
				row_false = false;
		if(!row_false)
			count++;
	}
	return count;
}

void print_marcs(std::vector<bool> &marcs, unsigned int ne1, unsigned int ne2) {
	for(unsigned int i = 0; i < ne1; i++) {
		for(unsigned int j = 0; j < ne2; j++) {
			std::cout<<marcs[i * ne2 + j]<<" ";
		}
		std::cout<<std::endl;
	}
}

void maxCommonEdgeSetBkt(unsigned int idx, std::vector<bool> marcs,
		std::vector<bool> &used_val,
		const std::vector<Vertex> &nodes1,
		const std::vector<Vertex> &nodes2,
		const std::vector< std::pair<Vertex,Vertex> > &edges1,
		const std::vector< std::pair<Vertex,Vertex> > &edges2,
		std::vector<int> &common,
		std::vector<int> &solution,
		unsigned int &bestarcsleft) {
	
	unsigned int i, j, arcsleft;
	std::vector<bool> marcs_new;
	/* try to not use this node in the matching process */
	/* VERTEX_NONE means that a correspondence for this node will
	 * not be searched for */
	common[idx] = VERTEX_NONE;
	marcs_new = marcs;
	arcsleft = refine_marcs_ignore_node(marcs_new, idx, edges1, edges2);
	if(arcsleft > bestarcsleft) {
		if(idx == nodes1.size() - 1) {
			bestarcsleft = arcsleft;
			solution = common;
			for(i = 0; i < common.size(); i++)
				std::cout<<common[i]<<" ";
			std::cout<<std::endl;
		} else {
			maxCommonEdgeSetBkt(idx + 1, marcs_new, used_val,
					nodes1, nodes2,
					edges1, edges2,
					common, solution, bestarcsleft);
		}
	}
	/* try to find a matching node */
	for(j = 0; j < nodes2.size(); j++) {
		/* if the node was previously matched to another node,
		 * then don't reuse it */
		if(used_val[j] == true)
			continue;
		/* both nodes have to be labeled with the same system call
		 * number */
		if(nodes1[idx].info.syscall_no == nodes2[j].info.syscall_no) {
			/* set value in partial solution */
			common[idx] = j;
			/* refine @marcs, marcs is passed by copy */
			marcs_new = marcs;
			arcsleft = refine_marcs(marcs_new, idx, j, edges1, edges2);
			/* continue only if a better solution is
			 * possible */
			if(arcsleft > bestarcsleft) {
				if(idx == nodes1.size() - 1) {
					bestarcsleft = arcsleft;
					solution = common;
					for(i = 0; i < common.size(); i++)
						std::cout<<common[i]<<" ";
					std::cout<<std::endl;
				} else {
					used_val[j] = true;
					maxCommonEdgeSetBkt(idx + 1, marcs_new,
							used_val,
							nodes1, nodes2,
							edges1, edges2,
							common, solution,
							bestarcsleft);
					used_val[j] = false;
				}
			}
		}
	}
}

std::vector<int> Graph::maximalCommonEdgeSet(Graph& graph) {

	unsigned int bestarcsleft = 0;
	std::vector<Vertex> nodes1, nodes2;
	std::vector< std::pair<Vertex,Vertex> > edges1, edges2;
	/* keep the graph with fewer nodes in G(nodes1,edges1) */
	if(vertexs.size() < graph.getVertexs().size()) {
		nodes1 = vertexs;
		edges1 = edges;
		nodes2 = graph.getVertexs();
		edges2 = graph.getEdges();
	} else {
		nodes1 = graph.getVertexs();
		edges1 = graph.getEdges();
		nodes2 = vertexs;
		edges2 = edges;
	}
	int ne1 = edges1.size();
	int ne2 = edges2.size();
	std::vector<int> common(nodes1.size(), -1);
	std::vector<int> solution(nodes1.size(), -1);
	std::vector<bool> marcs(ne1 * ne2, true);
	std::vector<bool> used_val(ne2, false);
	maxCommonEdgeSetBkt(0, marcs, used_val, nodes1, nodes2, edges1, edges2,
			common, solution, bestarcsleft);
	return solution;
}
