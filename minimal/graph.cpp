#include "graph.h"
#include <algorithm>

Graph::Graph() {
}

Graph::Graph(syscall_t* trace, int length) {
	for(int i = 0; i < length; i++) {
		addVertex(Vertex(i, trace[i]));
	}
}

Graph::~Graph() {
}

void Graph::addVertex(const Vertex &node) {
	vertexs.push_back(node);
}

bool Graph::hasVertex(const Vertex &node) {
	return find(vertexs.begin(), vertexs.end(), node) != vertexs.end();
}

void Graph::addEdge(const Vertex &from, const Vertex &to) {
	edges.push_back(std::pair<Vertex, Vertex>(from, to));
}

bool Graph::hasEdge(const Vertex &from, const Vertex &to) {
	return find(edges.begin(), edges.end(),
			std::make_pair(from, to)) != edges.end();
}

bool Graph::hasEdge(const std::pair<Vertex, Vertex> &edge) {
	return find(edges.begin(), edges.end(), edge) != edges.end();
}

std::vector< Vertex > Graph::getVertexs() {
	return vertexs;
}

std::vector< std::pair<Vertex,Vertex> > Graph::getEdges() {
	return edges;
}

std::ostream& operator<<(std::ostream& stream, const Graph& graph) {
	std::vector< Vertex >::const_iterator vit;
	std::vector< std::pair<Vertex,Vertex> >::const_iterator eit;
	/* print vertexes */
	stream<<"V={ ";
	for(vit = graph.vertexs.begin(); vit != graph.vertexs.end(); ++vit)
		stream<<"("<<vit->index<<" sc="<<vit->info.syscall_no<<"), ";
	stream<<"};"<<std::endl;
	/* print edges */
	stream<<"E={ ";
	for(eit = graph.edges.begin(); eit != graph.edges.end(); ++eit)
		stream<<"("<<eit->first.index<<", "<<eit->second.index<<"), ";
	stream<<"};"<<std::endl;
	return stream;
}

int Graph::genDependencyEdges(void) {
	int i, j, num = 0, n = vertexs.size();
	for(i = 0; i < n; i++) {
		for(j = i + 1; j < n; j++) {
			if(vertexs[j].dependsOn(vertexs[i])) {
				addEdge(vertexs[i], vertexs[j]);
				num++;
			}
		}
	}
	return 0;
}

std::vector< std::pair<Vertex,Vertex> > maximalCommonEdgeSet(Graph& graph) {
	std::vector< std::pair<Vertex,Vertex> > common;
	std::vector< std::pair<Vertex,Vertex> > edges2 = graph.getEdges();
	return common;
}
