#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <unistd.h> /* execve */

#include <stdlib.h> /* calloc */

#include "graphbuilder.h"
#include "util.h"

GraphBuilder::GraphBuilder(const char* pathfile, bool _aggregate): aggregate(_aggregate)
{
	std::vector<int> syscalls;
	int ret;

	child_sem = sem_open(CHILD_SEM_NAME, O_CREAT, 0644, 0);
	if(child_sem == SEM_FAILED) {
		std::cerr<<"error creating semaphore"<<std::endl;
		return;
	}

	if(!dec.load_file(pathfile)) {
		std::cerr<<"error reading syscalls xml file"<<std::endl;
		return;
	}

	std::cout<<"Monitored syscalls are: "<<std::endl;
	syscalls  = dec.read_monitored_syscalls();
	for(unsigned int i = 0; i < syscalls.size(); i++)
		std::cout<<syscalls[i]<<" ";
	std::cout<<std::endl;

	ret = set_monitored_syscalls(syscalls);
	if(ret < 0) {
		std::cerr<<"error configuring monitored syscalls"<<std::endl;
		return;
	}
}

GraphBuilder::~GraphBuilder(void)
{
	int ret;
	ret = sem_close(child_sem);
	if(ret < 0) {
		std::cerr<<"error closing named semaphore"<<std::endl;
	}
}

int GraphBuilder::set_monitored_syscalls(std::vector<int> syscalls)
{
	int fd, ret;
	int info;
	/* open system call interceptor driver */
	fd = open(SCID_DEVICE_PATH, O_RDWR);
	if(fd < 0) {
		std::cerr<<"failed to open scid device"<<std::endl;
		return -1;
	}
	/* set syscalls to monitor */
	for(unsigned int i = 0; i < syscalls.size(); i++) {
		info = syscalls[i];
		ret = ioctl(fd, IOCTL_ADD_SYSCALL, &info);
		if(ret != 0) {
			std::cerr<<"failed to register syscall"<<std::endl;
			return -1;
		}
	}
	/* close device */
	close(fd);
	return 0;
}

int GraphBuilder::read_trace(int fd, syscall_t** trace)
{
	int i, ret, count = 0;
	sctrace_t sct;
	ret = ioctl(fd, IOCTL_COUNT_HISTORY, &count);
	if(ret < 0) {
		std::cerr<<"failed to count history"<<std::endl;
		return -1;
	}
	std::cout<<"driver contains "<<count<<" syscall entries\n";

	*trace = (syscall_t*) calloc(count, sizeof(syscall_t));
	if(trace == NULL) {
		std::cerr<<"calloc no memory"<<std::endl;
		return -1;
	}

	for(i = 0; i < count; i++) {
		ret = ioctl(fd, IOCTL_READ_HISTORY, &sct);
		if(ret < 0) {
			std::cerr<<"failed to read history"<<std::endl;
			return -1;
		}
		(*trace)[i] = dec.decode(sct);
	}
	return count;
}

pid_t GraphBuilder::start_child(const char* pathfile)
{
	char *const argv[] = { NULL };
	char *const envp[] = { NULL };
	pid_t pid;
	int ret;
	pid = fork();
	switch(pid) {
		/* child process */
		case 0:
			/* sleep 1 second to have enough time to setup
			 * the scid driver */
			ret = sem_wait(child_sem);
			DIE(ret < 0, "error waiting for semaphore");
			ret = execve(pathfile, argv, envp);
			DIE(ret < 0, "error running execve");
			break;
		/* father process */
		default:
			DIE(pid < 0, "fork failed");
			/* else just return the child process's pid */
			break;
	}
	return pid;
}

int GraphBuilder::get_trace(const char* pathfile, syscall_t** trace)
{
	int fd, status, ret;
	pid_t child;
	/* open system call interceptor driver */
	fd = open(SCID_DEVICE_PATH, O_RDWR);
	DIE(fd < 0, "scid device open");

	/* create process and get pid */
	child = start_child(pathfile);
	/* set process pid to monitor */
	ret = ioctl(fd, IOCTL_SET_PID, &child);
	if(ret != 0) {
		std::cerr<<"failed to set pid"<<std::endl;
		return -1;
	}
	ret = sem_post(child_sem);
	DIE(ret < 0, "error posting semaphore");
	/* wait until process child ends to get a full trace of it's
	 * execution */
	ret = waitpid(child, &status, 0);

	/* read the program system call trace from driver */
	ret = read_trace(fd, trace);
	/* close device */
	close(fd);
	return ret;
}

Graph* GraphBuilder::build_graph(const char* pathfile)
{
	int count;
	syscall_t *trace = NULL;
	Graph *graph = NULL;
	std::cout<<"Getting system call trace for "<<pathfile<<std::endl;

	count = get_trace(pathfile, &trace);
	if(count < 0) {
		std::cerr<<"error getting trace"<<std::endl;
		return NULL;
	}
	graph = new Graph(trace, count);
	graph->generate_edges();

	if(aggregate)
		graph->aggregate_vertexs();

	free(trace);
	return graph;
}
