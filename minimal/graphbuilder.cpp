#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <unistd.h> /* execve */

#include <stdlib.h> /* calloc */
#include <string.h> /* strdup */

#include "graphbuilder.h"
#include "util.h"

#define DELIM	"\t "

GraphBuilder::GraphBuilder(const char* pathfile, bool _aggregate): aggregate(_aggregate)
{
	std::vector<int> syscalls;
	int ret;

	child_sem = sem_open(CHILD_SEM_NAME, O_CREAT, 0644, 0);
	if(child_sem == SEM_FAILED) {
		std::cerr<<"error creating semaphore"<<std::endl;
		return;
	}

	if(!dec.load_file(pathfile)) {
		std::cerr<<"error reading syscalls xml file"<<std::endl;
		return;
	}

	std::cout<<"Monitored syscalls are: "<<std::endl;
	syscalls  = dec.read_monitored_syscalls();
	for(unsigned int i = 0; i < syscalls.size(); i++)
		std::cout<<syscalls[i]<<" ";
	std::cout<<std::endl<<std::endl;

	ret = set_monitored_syscalls(syscalls);
	if(ret < 0) {
		std::cerr<<"error configuring monitored syscalls"<<std::endl;
		return;
	}
}

GraphBuilder::~GraphBuilder(void)
{
	int ret;
	ret = sem_close(child_sem);
	if(ret < 0) {
		std::cerr<<"error closing named semaphore"<<std::endl;
	}
}

char** GraphBuilder::parse_arguments(const char* command)
{
	int index = 0, num = 0;
	char *str, *p, *saveptr;
	const char* pc;
	char** args;

	str = strdup(command);
	if(str == NULL) {
		std::cerr<<"Error strdup command \""<<command<<"\"";
		std::cerr<<std::endl;
		return NULL;
	}

	pc = command;
	while(*pc) {
		while(*pc && (*pc == ' ' || *pc == '\t'))
			pc++;
		if(*pc && *pc != ' ' && *pc != '\t') {
			num++;
			while(*pc && *pc != ' ' && *pc != '\t')
				pc++;
		}
	}

	/* last arguments needs to be null */
	args = (char**)calloc(num + 1, sizeof(char*));
	if(args == NULL) {
		std::cerr<<"Error calloc parser"<<std::endl;
		free(str);
		return NULL;
	}

	p = strtok_r(str, DELIM, &saveptr);
	while(p) {
		args[index++] = strdup(p);
		p = strtok_r(NULL, DELIM, &saveptr);
	}
	free(str);
	return args;
}

int GraphBuilder::set_monitored_syscalls(std::vector<int> syscalls)
{
	int fd, ret;
	int info;
	/* open system call interceptor driver */
	fd = open(SCID_DEVICE_PATH, O_RDWR);
	if(fd < 0) {
		std::cerr<<"failed to open scid device"<<std::endl;
		return -1;
	}
	/* set syscalls to monitor */
	for(unsigned int i = 0; i < syscalls.size(); i++) {
		info = syscalls[i];
		ret = ioctl(fd, IOCTL_ADD_SYSCALL, &info);
		if(ret != 0) {
			std::cerr<<"failed to register syscall"<<std::endl;
			return -1;
		}
	}
	/* close device */
	close(fd);
	return 0;
}

int GraphBuilder::read_trace(int fd, syscall_t** trace)
{
	int i, ret, count = 0;
	sctrace_t sct;
	ret = ioctl(fd, IOCTL_COUNT_HISTORY, &count);
	if(ret < 0) {
		std::cerr<<"failed to count history"<<std::endl;
		return -1;
	}

	std::cout<<"Driver contains "<<count<<" syscall entries\n";

	*trace = (syscall_t*) calloc(count, sizeof(syscall_t));
	if(trace == NULL) {
		std::cerr<<"calloc no memory"<<std::endl;
		return -1;
	}

	for(i = 0; i < count; i++) {
		ret = ioctl(fd, IOCTL_READ_HISTORY, &sct);
		if(ret < 0) {
			std::cerr<<"failed to read history"<<std::endl;
			return -1;
		}
		(*trace)[i] = dec.decode(sct);
	}
	return count;
}

pid_t GraphBuilder::start_child(const char* pathfile)
{
	char **argv;
	char *envp[] = { NULL };
	pid_t pid;
	int ret;
	pid = fork();
	switch(pid) {
		/* child process */
		case 0:
			/* sleep 1 second to have enough time to setup
			 * the scid driver */
			ret = sem_wait(child_sem);
			DIE(ret < 0, "error waiting for semaphore");
			argv = parse_arguments(pathfile);
			DIE(argv == NULL, "error parsing arguments");
			ret = execve(argv[0], argv, envp);
			DIE(ret < 0, "error running execve");
			break;
		/* father process */
		default:
			DIE(pid < 0, "fork failed");
			/* else just return the child process's pid */
			break;
	}
	return pid;
}

int GraphBuilder::get_trace(const char* pathfile, syscall_t** trace)
{
	int fd, status, ret;
	pid_t child;
	/* open system call interceptor driver */
	fd = open(SCID_DEVICE_PATH, O_RDWR);
	DIE(fd < 0, "scid device open");

	/* create process and get pid */
	child = start_child(pathfile);
	/* set process pid to monitor */
	ret = ioctl(fd, IOCTL_SET_PID, &child);
	if(ret != 0) {
		std::cerr<<"failed to set pid"<<std::endl;
		return -1;
	}
	ret = sem_post(child_sem);
	DIE(ret < 0, "error posting semaphore");
	/* wait until process child ends to get a full trace of it's
	 * execution */
	ret = waitpid(child, &status, 0);

	/* read the program system call trace from driver */
	ret = read_trace(fd, trace);
	/* close device */
	close(fd);
	return ret;
}

Graph* GraphBuilder::build_graph(const char* pathfile)
{
	unsigned int nodes;
	unsigned int edges;
	int count;
	syscall_t *trace = NULL;
	Graph *graph = NULL;
	std::cout<<"Getting system call trace for "<<pathfile<<std::endl;

	count = get_trace(pathfile, &trace);
	if(count < 0) {
		std::cerr<<"error getting trace"<<std::endl;
		return NULL;
	}
	graph = new Graph(trace, count);
	graph->generate_edges();

	nodes = graph->getVertexs().size();
	edges = graph->getEdges().size();

	if(aggregate) {
		graph->aggregate_vertexs();
		printf("\t\t   Nodes  Edges\n");
		printf("Initial graph    : %-6u %-6u\n", nodes, edges);
		printf("After aggregation: %-6u %-6u\n",
				graph->getVertexs().size(),
				graph->getEdges().size()
				);
	} else {
		printf("Graph, no aggreg.: %-4u %-4u\n", nodes, edges);
	}

	free(trace);
	return graph;
}
