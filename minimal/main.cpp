#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <error.h>
#include <unistd.h> /* execve */

#include <stdlib.h>
#include <stdio.h>
#include <iostream>

#include "graph.h"	/* graph representation */
#include "malspec.h"	/* malspec algorithm implementation */
#include "scdecoder.h"	/* decoding syscalls xml */
#include "util.h"

SCDecoder dec;

int read_driver(int fd, syscall_t** trace)
{
	int i, ret, count = 0;
	sctrace_t sct;
	ret = ioctl(fd, IOCTL_COUNT_HISTORY, &count);
	if(ret < 0) {
		perror("failed to count history");
		return -1;
	}
	std::cout<<"driver contains "<<count<<" syscall entries\n";

	*trace = (syscall_t*) calloc(count, sizeof(syscall_t));
	DIE(trace == NULL, "calloc no memory");

	for(i = 0; i < count; i++) {
		ret = ioctl(fd, IOCTL_READ_HISTORY, &sct);
		DIE(ret < 0, "failed to read history");
		(*trace)[i] = dec.decode(sct);
	}
	return count;
}

pid_t start_child(char* pathfile)
{
	char *const argv[] = { NULL };
	char *const envp[] = { NULL };
	pid_t pid;
	int ret;
	pid = fork();
	switch(pid) {
		/* child process */
		case 0:
			/* sleep 1 second to have enough time to setup
			 * the scid driver */
			sleep(1);
			ret = execve(pathfile, argv, envp);
			DIE(ret != 0, "error running execve");
			break;
		/* father process */
		default:
			DIE(pid < 0, "fork failed");
			/* else just return the child process's pid */
			break;
	}
	return pid;
}

int set_monitored_syscalls(std::vector<int> syscalls)
{
	int fd, ret;
	int info;
	/* open system call interceptor driver */
	fd = open(DEVICE_PATH, O_RDWR);
	DIE(fd < 0, "scid device open");

	/* set syscalls to monitor */
	for(unsigned int i = 0; i < syscalls.size(); i++) {
		info = syscalls[i];
		ret = ioctl(fd, IOCTL_ADD_SYSCALL, &info);
		if(ret != 0) {
			perror("failed to register syscall");
			return -1;
		}
	}

	/* close device */
	close(fd);
	return 0;
}

int get_trace(char* pathfile, syscall_t** trace)
{
	int fd, status, ret;
	pid_t child;
	/* open system call interceptor driver */
	fd = open(DEVICE_PATH, O_RDWR);
	DIE(fd < 0, "scid device open");

	/* create process and get pid */
	child = start_child(pathfile);
	/* set process pid to monitor */
	ret = ioctl(fd, IOCTL_SET_PID, &child);
	if(ret != 0) {
		perror("failed to set pid");
	}
	/* wait until process child ends to get a full trace of it's
	 * execution */
	ret = waitpid(child, &status, 0);

	/* read the program system call trace from driver */
	ret = read_driver(fd, trace);
	/* close device */
	close(fd);
	return ret;
}

Graph* get_graph(char* pathfile)
{
	int count;
	syscall_t *trace = NULL;
	Graph *graph = NULL;
	std::cout<<"Getting system call trace for "<<pathfile<<std::endl;

	count = get_trace(pathfile, &trace);
	DIE(count < 0, "error getting trace");
	graph = new Graph(trace, count);
	graph->generate_edges();

	free(trace);
	return graph;
}

int main(int argc, char* argv[])
{
	int ret;
	Graph *graph1, *graph2;
	std::vector<Graph*> min_contrast;
	std::vector<int> syscalls, coresp;

	if(!dec.load_file(argv[1])) {
		std::cout<<"error reading syscalls xml file"<<std::endl;
		return 0;
	}

	std::cout<<"Monitored syscalls are: "<<std::endl;
	syscalls  = dec.read_monitored_syscalls();
	for(unsigned int i = 0; i < syscalls.size(); i++)
		std::cout<<syscalls[i]<<" ";
	std::cout<<std::endl;

	ret = set_monitored_syscalls(syscalls);
	DIE(ret < 0, "error setting monitored syscalls");

	graph1 = get_graph(argv[2]);
	graph2 = get_graph(argv[3]);
	std::cout<<*graph1;
	std::cout<<*graph2;

	std::cout<<"Aggregated:"<<std::endl<<std::endl;
	graph1->aggregate_vertexs();
	graph2->aggregate_vertexs();

	std::cout<<*graph1;
	std::cout<<*graph2;

	std::cout<<"Minimal contrast subgraph set"<<std::endl<<std::endl;

	min_contrast = minimal_contrast_subgraph_set(graph1, graph2);
	for(unsigned int i = 0; i < min_contrast.size(); i++)
		std::cout<<"Diff "<<i<<std::endl<<*min_contrast[i]<<std::endl;

	delete graph1;
	delete graph2;
	for(unsigned int i = 0; i < min_contrast.size(); i++)
		delete min_contrast[i];
	return 0;
}
