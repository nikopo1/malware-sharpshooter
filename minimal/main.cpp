#include "graph.h"
#include <iostream>

#include <stdlib.h>
#include <stdio.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <error.h>
#include <unistd.h> /* execve */

#define DEVICE_PATH	"/proc/scid"
#define DIE(failcondition, errormsg)		\
	do {					\
		if((failcondition)) {		\
			perror((errormsg));	\
			_exit(-1);		\
		}				\
	} while(0)

int read_driver(int fd, syscall_t** trace)
{
	int i, ret, count = 0;
	sctrace_t sct;
	ret = ioctl(fd, IOCTL_COUNT_HISTORY, &count);
	if(ret < 0) {
		perror("failed to count history");
		return -1;
	}
	std::cout<<"driver contains "<<count<<" syscall entries\n";

	*trace = (syscall_t*) calloc(count, sizeof(syscall_t));
	DIE(trace == NULL, "calloc no memory");

	for(i = 0; i < count; i++) {
		ret = ioctl(fd, IOCTL_READ_HISTORY, &sct);
		DIE(ret < 0, "failed to read history");
		(*trace)[i] = decode_syscall(sct);
	}
	return count;
}

pid_t start_child(char* pathfile)
{
	char *const argv[] = { NULL };
	char *const envp[] = { NULL };
	pid_t pid;
	int ret;
	pid = fork();
	switch(pid) {
		/* child process */
		case 0:
			/* sleep 1 second to have enough time to setup
			 * the scid driver */
			sleep(1);
			ret = execve(pathfile, argv, envp);
			DIE(ret != 0, "error running execve");
			break;
		/* father process */
		default:
			DIE(pid < 0, "fork failed");
			/* else just return the child process's pid */
			break;
	}
	return pid;
}

int get_trace(char* pathfile, std::vector<int> syscalls, syscall_t** trace)
{
	int fd, status, ret;
	pid_t child;
	int info;
	fd = open(DEVICE_PATH, O_RDWR);
	DIE(fd < 0, "scid device open");
	/* set syscalls to monitor */
	for(unsigned int i = 0; i < syscalls.size(); i++) {
		info = syscalls[i];
		ret = ioctl(fd, IOCTL_ADD_SYSCALL, &info);
		if(ret != 0) {
			perror("failed to register syscall");
		}
	}

	/* create process and get pid */
	child = start_child(pathfile);
	/* set process pid to monitor */
	ret = ioctl(fd, IOCTL_SET_PID, &child);
	if(ret != 0) {
		perror("failed to set pid");
	}
	/* wait until process child ends to get a full trace of it's
	 * execution */
	ret = waitpid(child, &status, 0);

	/* read the program system call trace from driver */
	ret = read_driver(fd, trace);
	return ret;
}

void run_test(void)
{
	Graph graph;
	syscall_t info;
	memset(&info, 0, sizeof(syscall_t));

	Vertex vertex1(1, info);
	Vertex vertex2(2, info);

	graph.addVertex(vertex1);
	graph.addVertex(*(new Vertex(2, info)));
	graph.addEdge(vertex1, vertex2);
	std::cout<<graph;

	std::cout<<sizeof(param_t)<<std::endl;
}

int main(int argc, char* argv[])
{
	
	int ret, count;
	std::vector<int> syscalls;
	syscall_t *trace = NULL;
	if(argc == 1) {
		std::cout<<"Running test...\n";
		run_test();
		return 0;
	}
	syscalls.push_back(3); /* read */
	syscalls.push_back(4); /* write */
	syscalls.push_back(5); /* open */
	syscalls.push_back(6); /* close */
	std::cout<<"Getting system call trace for "<<argv[1]<<std::endl;

	count = get_trace(argv[1], syscalls, &trace);
	DIE(count < 0, "error getting trace");

	Graph graph(trace, count);
	graph.generateDepEdges();
	std::cout<<graph;

	return 0;
}
