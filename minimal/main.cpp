#include "graph.h"
#include "util.h"

#include <iostream>

#include <stdlib.h>
#include <stdio.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <error.h>
#include <unistd.h> /* execve */


int read_driver(int fd, syscall_t** trace)
{
	int i, ret, count = 0;
	sctrace_t sct;
	ret = ioctl(fd, IOCTL_COUNT_HISTORY, &count);
	if(ret < 0) {
		perror("failed to count history");
		return -1;
	}
	std::cout<<"driver contains "<<count<<" syscall entries\n";

	*trace = (syscall_t*) calloc(count, sizeof(syscall_t));
	DIE(trace == NULL, "calloc no memory");

	for(i = 0; i < count; i++) {
		ret = ioctl(fd, IOCTL_READ_HISTORY, &sct);
		DIE(ret < 0, "failed to read history");
		(*trace)[i] = decode_syscall(sct);
	}
	return count;
}

pid_t start_child(char* pathfile)
{
	char *const argv[] = { NULL };
	char *const envp[] = { NULL };
	pid_t pid;
	int ret;
	pid = fork();
	switch(pid) {
		/* child process */
		case 0:
			/* sleep 1 second to have enough time to setup
			 * the scid driver */
			sleep(1);
			ret = execve(pathfile, argv, envp);
			DIE(ret != 0, "error running execve");
			break;
		/* father process */
		default:
			DIE(pid < 0, "fork failed");
			/* else just return the child process's pid */
			break;
	}
	return pid;
}

int set_monitored_syscalls(std::vector<int> syscalls)
{
	int fd, ret;
	int info;
	/* open system call interceptor driver */
	fd = open(DEVICE_PATH, O_RDWR);
	DIE(fd < 0, "scid device open");

	/* set syscalls to monitor */
	for(unsigned int i = 0; i < syscalls.size(); i++) {
		info = syscalls[i];
		ret = ioctl(fd, IOCTL_ADD_SYSCALL, &info);
		if(ret != 0) {
			perror("failed to register syscall");
			return -1;
		}
	}

	/* close device */
	close(fd);
	return 0;
}

int get_trace(char* pathfile, syscall_t** trace)
{
	int fd, status, ret;
	pid_t child;
	/* open system call interceptor driver */
	fd = open(DEVICE_PATH, O_RDWR);
	DIE(fd < 0, "scid device open");

	/* create process and get pid */
	child = start_child(pathfile);
	/* set process pid to monitor */
	ret = ioctl(fd, IOCTL_SET_PID, &child);
	if(ret != 0) {
		perror("failed to set pid");
	}
	/* wait until process child ends to get a full trace of it's
	 * execution */
	ret = waitpid(child, &status, 0);

	/* read the program system call trace from driver */
	ret = read_driver(fd, trace);
	/* close device */
	close(fd);
	return ret;
}

int get_graph(char* pathfile, Graph &graph)
{
	int count;
	syscall_t *trace = NULL;
	std::cout<<"Getting system call trace for "<<pathfile<<std::endl;

	count = get_trace(pathfile, &trace);
	DIE(count < 0, "error getting trace");
	graph.generateVertexes(trace, count);
	graph.generateDepEdges();

	free(trace);
	return count;
}

void run_test(void)
{
	/* Old test code
	Graph graph;
	syscall_t info;
	memset(&info, 0, sizeof(syscall_t));

	Vertex vertex1(1, info);
	Vertex vertex2(2, info);

	graph.addVertex(vertex1);
	graph.addVertex(*(new Vertex(2, info)));
	graph.addEdge(vertex1, vertex2);
	std::cout<<graph;

	std::cout<<sizeof(param_t)<<std::endl;
	*/
}

int main(int argc, char* argv[])
{
	int ret;
	unsigned int i;
	Graph graph1, graph2, *compl1;
	std::vector<int> syscalls, coresp;
	std::vector< std::pair<Vertex*, Vertex*> > traversal;

	if(argc == 1) {
		std::cout<<"Running test...\n";
		run_test();
		return 0;
	}

	syscalls.push_back(3); /* read */
	syscalls.push_back(4); /* write */
	syscalls.push_back(5); /* open */
	syscalls.push_back(6); /* close */
	ret = set_monitored_syscalls(syscalls);
	DIE(ret < 0, "error setting monitored syscalls");

	get_graph(argv[1], graph1);
	get_graph(argv[2], graph2);
	std::cout<<graph1;
	std::cout<<graph2;

	coresp = graph1.maximalCommonEdgeSet(graph2);
	std::cout<<"Corespondence vector: ";
	for(i = 0; i < coresp.size(); i++)
		std::cout<<coresp[i]<<" ";
	std::cout<<std::endl;

	compl1 = graph1.subgraphComplement(coresp);
	std::cout<<"Subgraph complement is: "<<std::endl<<*compl1;

	traversal = graph1->minimalTraversal();
	for(i = 0; i < traversal.size(); i++)
		std::cout<<"("<<traversal[i].first->index<<", "<<traversal[i].second->index<<"), ";
	std::cout<<std::endl;

	delete compl1;
	return 0;
}
