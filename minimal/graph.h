#ifndef _GRAPH_H_
#define _GRAPH_H_

#include "vertex.h"

#include <vector>
#include <iostream>

#define VERTEX_NONE	-1

class Graph {

	std::vector< Vertex* > vertexs;
	std::vector< std::vector<Vertex*> > edges;
public:
	/*
	 * Static variable used for activating debug printing.
	 */
	static bool debug;
	/* constructors and destructors */
	Graph();
	Graph(syscall_t* trace, int length);
	virtual ~Graph();

	/* general usage methods */

	/*
	 * Adds the vertex to this graph on the last position in the
	 * vector and creates an edge vector for it.
	 */
	void add_vertex(Vertex *node);

	/*
	 * Returns true if this graph contains the vertex given as
	 * parameter. Uses node->index value.
	 */
	bool has_vertex(Vertex *node);

	/*
	 * Removes the vertex given as parameter and all edges connnected to
	 * it.
	 */
	bool remove_vertex(Vertex *node);

	/*
	 * Uses index values from the vertices given as parameters.
	 */
	void add_edge(Vertex *from, Vertex *to);

	/*
	 * Note: used onlt in union method. Uses the index values
	 * provided by @from and @to.
	 */
	void add_edge(unsigned int from, unsigned int to);
	/*
	 * Note: used only in aggregation method. Searches by index
	 * values.
	 */
	bool has_edge(Vertex *from, Vertex *to);

	/*
	 * Tests equality between _this_ and the other graph. Uses the maximal
	 * common edge set algorithm to determine the vertexs corespondence so
	 * this is an expensive operation.
	 */
	bool equals(const Graph *other);

	std::vector< Vertex* > getVertexs() const;
	std::vector< std::pair<Vertex*,Vertex*> > getEdges() const;
	std::vector< Vertex* > getNeighbours(unsigned int index);
	std::vector< Vertex* > getNeighbours(Vertex *vertex);

	friend std::ostream& operator<<(std::ostream& stream, const Graph& graph);
	
	/* algorithm methods */

	/*
	 * Adds all the necesary vertexes to represent the trace given
	 * as parameter.
	 */
	void generate_vertexs(syscall_t* trace, int length);

	/*
	 * Generates all the def-use depency edges inside the graph
	 * according to the values already contained in the vertexs.
	 */
	int generate_edges(void);

	/*
	 * Combines these two vertexes. Vertices must have the same
	 * label or this operation will fail.
	 */
	bool merge_vertexs(Vertex* v1, Vertex* v2);

	/* Combines two vertices v1, v2 with the following properties:
	 *   1) v1 and v2 are labelled with the same syscall
	 *   2) v1 and v2 have a def-use edge to a common parent
	 *   3) there is no syscall between v1 and v2 in execution order
	 *   that operates on the same resource as v1 and v2
	 */
	void aggregate_vertexs(void);

	/*
	 * Removes all the vertices that don't have an edge with it.
	 */
	void clear_isolated_vertexs(void);

	/*
	 * Determines the maximal common edge set between this graph and
	 * the other graph. Returns for each node in this graph the
	 * index of the corresponding node from the other graph.
	 */
	std::vector<int> maximal_common_edge_set(const Graph* other);

	/*
	 * Returns a new graph which is the subgraph complement
	 * according to the node matches found in vertex_subset (i.e. all
	 * the nodes that don't have a corresponding node:
	 * vertex_subset[i] == VERTEX_NONE).
	 */
	Graph* subgraph_complement(std::vector<int>& vertex_subset);

	/*
	 * Returns true if _this_ is a subgraph of the other graph.
	 */
	bool is_subgraph(Graph* other);

	/*
	 * Adds to traversal the edges found my exploring the graph in a
	 * breadth first search manner starting in vertex start.
	 */
	void bfs_transversal(Vertex *start, std::vector< std::pair<Vertex*, Vertex*> > &transversal);

	/*
	 * Makes a union between _this_ graph and the _other_ graph in
	 * place.
	 */
	void append_graph(Graph* other);

	/*
	 * Makes a copy of _this_ graph's vertexs but with no edges
	 * included
	 */
	Graph* vertex_copy(void);

	/*
	 * Returns the union (disjoint) of graph1 with graph2.
	 */
	static Graph* union_graph(Graph* graph1, Graph* graph2);

private:
	/*
	 * Made private in order to prevent such usage.
	 */
	Graph& operator=(const Graph& other);
};
#endif
