#ifndef _GRAPH_H_
#define _GRAPH_H_

#include "vertex.h"

#include <vector>
#include <iostream>

#define VERTEX_NONE	-1

class Graph {

	std::vector< Vertex* > vertexs;
	std::vector< std::vector<Vertex*> > edges;
public:
	static bool debug;
	/* constructors and destructors */
	Graph();
	Graph(syscall_t* trace, int length);
	Graph(const Graph& other, std::vector<int> vertex_subset);

	virtual ~Graph();
	/* general usage methods */
	void addVertex(Vertex *node);
	bool hasVertex(Vertex *node);

	void addEdge(Vertex *from, Vertex *to);
	void addEdge(unsigned int from, unsigned int to);
	bool hasEdge(Vertex *from, Vertex *to);

	void clear_isolated_vertexs(void);

	std::vector< Vertex* > getVertexs();
	std::vector< std::pair<Vertex*,Vertex*> > getEdges() const;
	std::vector< Vertex* > getNeighbours(unsigned int index);
	std::vector< Vertex* > getNeighbours(Vertex *vertex);

	friend std::ostream& operator<<(std::ostream& stream, const Graph& graph);
	
	/* algorithm methods */

	/*
	 * Adds all the necesary vertexes to represent the trace given
	 * as parameter.
	 */
	void generateVertexes(syscall_t* trace, int length);

	/*
	 * Generates all the def-use depency edges inside the graph
	 * according to the values already contained in the vertexs.
	 */
	int generateDepEdges(void);

	/*
	 * Determines the maximal common edge set between this graph and
	 * the other graph. Returns for each node in this graph the
	 * index of the corresponding node from the other graph.
	 */
	std::vector<int> maximalCommonEdgeSet(Graph* other);

	/*
	 * Returns a new graph which is the subgraph complement
	 * according to the node matches found in vertex_subset (i.e. all
	 * the nodes that don't have a corresponding node:
	 * vertex_subset[i] == VERTEX_NONE).
	 */
	Graph* subgraphComplement(std::vector<int>& vertex_subset);

	/*
	 * Returns true if _this_ is a subgraph of the other graph.
	 */
	bool is_subgraph(Graph* other);

	/*
	 * Adds to traversal the edges found my exploring the graph in a
	 * breadth first search manner starting in vertex start.
	 */
	void bfs_transversal(Vertex *start, std::vector< std::pair<Vertex*, Vertex*> > &transversal);

	/*
	 * Makes a union between _this_ graph and the _other_ graph in
	 * place.
	 */
	void append_graph(Graph* other);

	/*
	 * Makes a copy of _this_ graph's vertexs but with no edges
	 * included
	 */
	Graph* vertex_copy(void);

	/*
	 * Returns the union (disjoint) of graph1 with graph2.
	 */
	static Graph* union_graph(Graph* graph1, Graph* graph2);

private:
	/*
	 * Made private in order to prevent such usage.
	 */
	Graph& operator=(const Graph& other);
};
#endif
