#include "vertex.h"

int Vertex::crt = 0;

Vertex::Vertex(int _index, syscall_t _syscall): index(_index), info(_syscall), visited(false) {
	crt++;
}

Vertex::Vertex(const Vertex &other): index(other.index), info(other.info), visited(other.visited) {
	crt++;
}

Vertex::~Vertex() {
}

bool Vertex::dependsOn(Vertex* other) {
	/* try each pair of parameters and see if _this_ vertex has any
	 * IN/INOUT parameter that is also an OUT/INOUT parameter of
	 * the @other vertex */
	for(int i = 0; i < MAX_NUM_PARAM; i++) {
		/* check to see if the ith param is used */
		if(info.param[i].type == TYPE_NONE)
			continue;
		for(int j = 0; j < MAX_NUM_PARAM; j++) {
			/* check to see if the jth param is use */
			if(other->info.param[j].type == TYPE_NONE)
				continue;
			if(info.param[i].type == other->info.param[j].type)
				if((info.param[i].dir & DIR_IN) && 
						(other->info.param[j].dir & DIR_OUT)) {
					/* should be treated differently
					 * accoding to syscall param
					 * types */
					if(info.param[i].value == other->info.param[j].value)
						return true;
				}
		}
	}
	return false;
}

bool Vertex::closesVertex(Vertex* other) {
	if(info.syscall_no == __NR_close &&
			other->info.syscall_no == __NR_open) {
		return dependsOn(other);
	}
	return false;
}

bool Vertex::operator== (const Vertex& other) const {
	return index == other.index;
}

bool Vertex::operator< (const Vertex& other) const {
	return index - other.index;
}

Vertex& Vertex::operator= (const Vertex& other) {
	index = other.index;
	return *this;
}
