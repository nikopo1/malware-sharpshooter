#ifndef _PARAM_H_
#define _PARAM_H_

#include "scid.h"
#include <string.h> /* memset */
#include <asm/unistd_32.h>

#define MAX_NUM_PARAM	8
/* for error or not used */
#define TYPE_NONE	0
/* possible type values for struct param */
#define TYPE_INT	1
#define TYPE_FD		2
#define TYPE_PCHAR	3
#define TYPE_PVOID	4
#define TYPE_USHORT	5
#define TYPE_SIZE_T	6
#define TYPE_VOID	7

/* possible dir values for struct param */
#define DIR_NONE	0x00
#define DIR_IN		0x01
#define DIR_OUT		0x02
#define DIR_INOUT	0x03

/* param data structure to describe a syscall's parameters */
typedef struct param {
	unsigned char type; /* fd, int, char*, void*, unsigned short */
	unsigned char dir; /* 1 in, 2 out, 3 inout */
	long value;
} param_t;

typedef struct _syscall_t {
	int syscall_no;        /* the system call number */
	param_t param[MAX_NUM_PARAM]; /* last element is the return value */
} syscall_t;

inline  syscall_t decode_open_param(sctrace_t sct) {
	syscall_t ret;
	memset(&ret, 0, sizeof(syscall_t));
	ret.syscall_no = sct.sc_no;
	/* const char* pathname */
	ret.param[0].value = sct.sc_params.ebx;
	ret.param[0].type  = TYPE_PCHAR;
	ret.param[0].dir   = DIR_IN;
	/* int flags */
	ret.param[1].value = sct.sc_params.ecx;
	ret.param[1].type  = TYPE_INT;
	ret.param[1].dir   = DIR_IN;
	/* mode_t mode */
	ret.param[2].value = sct.sc_params.edx;
	ret.param[2].type  = TYPE_USHORT;
	ret.param[2].dir   = DIR_IN;
	/* return: file descriptor */
	ret.param[7].value = sct.ret;
	ret.param[7].type  = TYPE_FD;
	ret.param[7].dir   = DIR_OUT;
	return ret;
}

inline syscall_t decode_read_param(sctrace_t sct) {
	syscall_t ret;
	memset(&ret, 0, sizeof(syscall_t));
	ret.syscall_no = sct.sc_no;
	/* int fd */
	ret.param[0].value = sct.sc_params.ebx;
	ret.param[0].type  = TYPE_FD;
	ret.param[0].dir   = DIR_IN;
	/* void* buf */
	ret.param[1].value = sct.sc_params.ecx;
	ret.param[1].type  = TYPE_PVOID;
	ret.param[1].dir   = DIR_OUT;
	/* size_t count */
	ret.param[2].value = sct.sc_params.edx;
	ret.param[2].type  = TYPE_SIZE_T;
	ret.param[2].dir   = DIR_INOUT;
	/* return: size_t num_bytes_read */
	ret.param[7].value = sct.ret;
	ret.param[7].type  = TYPE_SIZE_T;
	ret.param[7].dir   = DIR_OUT;
	return ret;
}

inline syscall_t decode_write_param(sctrace_t sct) {
	syscall_t ret;
	memset(&ret, 0, sizeof(syscall_t));
	ret.syscall_no = sct.sc_no;
	/* int fd */
	ret.param[0].value = sct.sc_params.ebx;
	ret.param[0].type  = TYPE_FD;
	ret.param[0].dir   = DIR_IN;
	/* void* buf */
	ret.param[1].value = sct.sc_params.ecx;
	ret.param[1].type  = TYPE_PVOID;
	ret.param[1].dir   = DIR_IN;
	/* size_t count */
	ret.param[2].value = sct.sc_params.edx;
	ret.param[2].type  = TYPE_SIZE_T;
	ret.param[2].dir   = DIR_INOUT;
	/* return: size_t num_bytes_written */
	ret.param[7].value = sct.ret;
	ret.param[7].type  = TYPE_SIZE_T;
	ret.param[7].dir   = DIR_OUT;
	return ret;
}

inline syscall_t decode_close_param(sctrace_t sct) {
	syscall_t ret;
	memset(&ret, 0, sizeof(syscall_t));
	ret.syscall_no = sct.sc_no;
	/* int fd */
	ret.param[0].value = sct.sc_params.ebx;
	ret.param[0].type  = TYPE_FD;
	ret.param[0].dir   = DIR_IN;
	/* return: size_t num_bytes_written */
	ret.param[7].value = sct.ret;
	ret.param[7].type  = TYPE_VOID;
	ret.param[7].dir   = DIR_NONE;
	return ret;
}

inline syscall_t decode_syscall(sctrace_t sct) {
	syscall_t ret;
	ret.syscall_no = 0;
	switch(sct.sc_no) {
		case __NR_open:
			return decode_open_param(sct);
		case __NR_read:
			return decode_read_param(sct);
		case __NR_write:
			return decode_write_param(sct);
		case __NR_close:
			return decode_close_param(sct);
		default:
			break;
	}
	return ret;
}

#endif
