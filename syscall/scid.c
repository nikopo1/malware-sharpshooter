/*
 * System call interceptor driver
 *
 * @author Cristian Condurache
 *
 */

#include <linux/module.h>
#include <linux/init.h>
#include <linux/kernel.h>

#include <linux/fs.h>         /* file_operations, inode & co */
#include <linux/proc_fs.h>    /* proc_symlink */
#include <linux/slab.h>       /* kmalloc & co */
#include <linux/miscdevice.h> /* miscdev register */

#include "scid.h"
#include "../include/param.h"

MODULE_DESCRIPTION("System call interceptor device");
MODULE_AUTHOR("Cristian Condurache");
MODULE_LICENSE("GPL");

#define LOG_LEVEL KERN_DEBUG

/* data struct for syscall intercepting */
struct syscall_params {
	long ebx, ecx, edx, esi, edi, ebp, eax;
};

/* data struct for monitored syscall numbers */
struct sc_list_t {
	struct list_head list;
	unsigned int sc_no;
};


/* OS system call table */
extern void *sys_call_table[];
extern long my_nr_syscalls;

static void **table_backup;
static spinlock_t sys_call_lock;

/* device access */
atomic_t dev_access;

/* process to be monitored */
static int pid;

static asmlinkage long interceptor(struct syscall_params scp) {
	long syscall, ret;
	long (*f)(struct syscall_params);
	syscall = scp.eax;i

	/* read syscall handler pointer */

	ret = f(scp);
	if(find_sc(syscall)) {
		printk(LOG_LEVEL "intercepted!");
	}
	return ret;
}

static int scid_open(struct inode *inode, struct file *file)
{
	if(atomic_cmpxchg(&dev_access, 1, 0) != 1)
		return -EBUSY;
	printk(LOG_LEVEL "Device data file opened\n");
	return 0;
}

static int scid_release(struct inode *node, struct file *file)
{
	printk(LOG_LEVEL "Device data file closed\n");
	atomic_inc(&dev_access);
	return 0;
}

static int scid_read(struct file *file, char __user *user_buffer,
		size_t size, loff_t *offset)
{
	return 0;
}

static long scid_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
	int ret = 0;
	switch(cmd) {
		case IOCTL_ADD_SYSCALL:
			ret = add_sc(arg);
			break;
		case IOCTL_DEL_SYSCALL:
			ret = del_sc(arg);
			break;
		case IOCTL_CLEAR_HISTORY:
			/* TODO: add history list clear */
			break;
		case IOCTL_COUNT_HISTORY:
			/* TODO: return total number of syscalls */
			break;
		default:
			ret = -EINVAL;
	}
	return ret;
}

static const struct file_operations scid_fops = {
	.owner = THIS_MODULE,
	.open = scid_open,
	.release = scid_release,
	.read = scid_read,
	.unlocked_ioctl= scid_ioctl,
};

static struct miscdevice scid_dev = {
	.minor	= SCID_DEV_MINOR,
	.name	= SCID_DEV_NAME,
	.fops	= &scid_fops,
};

static int __init scid_init(void)
{
	int ret;
	struct proc_dir_entry* ent;

	printk(LOG_LEVEL "SCID: starting driver...");
	atomic_set(&dev_access, 1);
	ret = misc_register(&scid_dev);
	if(ret != 0) {
		printk(LOG_LEVEL "SCID: device register fail\n");
		return ret;
	}
	ent = proc_symlink(SCID_DEV_NAME, NULL, "/dev/scid");
	if(ent == NULL) {
		printk(LOG_LEVEL "SCID: proc symlink creation fail\n");
		return -ENOMEM;
	}

	printk(LOG_LEVEL "SCID: ...done\n");
	return 0;
}

static void __exit scid_exit(void)
{
	printk(LOG_LEVEL "SCID: stopping driver...");

	misc_deregister(&scid_dev);
	remove_proc_entry(SCID_DEV_NAME, NULL);
	clear_sc();

	printk(LOG_LEVEL "SCID: ...done\n");
}

module_init(scid_init);
module_exit(scid_exit);
