/*
 * System call interceptor driver
 *
 * @author Cristian Condurache
 *
 */

#include <linux/module.h>
#include <linux/init.h>
#include <linux/kernel.h>

#include <linux/sched.h>      /* task_struct */
#include <linux/fs.h>         /* file_operations, inode & co */
#include <linux/proc_fs.h>    /* proc_symlink */
#include <linux/slab.h>       /* kmalloc & co */
#include <linux/miscdevice.h> /* miscdev register */
#include <linux/uaccess.h>    /* copy_from_user */

#include "../include/scid.h"

MODULE_DESCRIPTION("System call interceptor device");
MODULE_AUTHOR("Cristian Condurache");
MODULE_LICENSE("GPL");

#define LOG_LEVEL KERN_DEBUG

#define list_head_entry(list, type, member)	\
	list_entry((list)->next, type, member)

/* process to be monitored */
static int pid = 0;

module_param(pid, int, S_IRUSR);
MODULE_PARM_DESC(pid, "process pid to be monitored");

/*
 * OS system call tables
 *
 * These tables will be used for swapping interceptor and syscall
 * function addresses forward and backwards.
 *
 * If a syscall _IS NOT_ monitored, then a null value will be kept on
 * the corresponding position in table_backup.
 *
 * If a syscall _IS_ monitored, then the old syscall handler pointer
 * will be kept in table_backup, while the working copy value in
 * sys_call_table will be the interceptor handler funtion pointer.
 */
extern void *sys_call_table[];
extern long my_nr_syscalls;

static void **table_backup;
static spinlock_t sys_call_lock;

/* device access */
atomic_t dev_access;

/* system call trace history, time ordered */
struct sc_list_entry {
	struct list_head list;
	sctrace_t sc;
};

/* system call trace history list sychronized access in case user reads
 * info or clears list and is preempted, and then a new syscall is
 * registered. count will be incremented/decremented with spinlock
 * protection, so there's no need for atomic_t */
static int count = 0;
static struct list_head sc_history_list;
static spinlock_t sc_history_lock;

static int add_history(sctrace_t sc) {
	struct sc_list_entry *pe;
	spin_lock(&sc_history_lock);
	pe = kmalloc(sizeof(struct sc_list_entry), GFP_ATOMIC);
	if(pe == NULL) {
		spin_unlock(&sc_history_lock);
		return -ENOMEM;
	}
	pe->sc = sc;
	list_add_tail(&pe->list, &sc_history_list);
	count++;
	spin_unlock(&sc_history_lock);
	return 0;
}

static int head_remove_history(sctrace_t* sctrace) {
	struct sc_list_entry *pe;
	spin_lock(&sc_history_lock);
	/* if list is empty, return error */
	if(list_empty(&sc_history_list)) {
		spin_unlock(&sc_history_lock);
		return -EINVAL;
	}
	/* this should get the head of the list */
	pe = list_head_entry(&sc_history_list, struct sc_list_entry, list);
	*sctrace = pe->sc;
	list_del(&pe->list);
	count--;
	spin_unlock(&sc_history_lock);
	kfree(pe);
	return 0;
}

static void clear_history(void) {
	struct sc_list_entry *p, *tmp;
	spin_lock(&sc_history_lock);
	list_for_each_entry_safe(p, tmp, &sc_history_list, list) {
		list_del(&p->list);
		kfree(p);
	}
	count = 0;
	spin_unlock(&sc_history_lock);
}

static asmlinkage long interceptor(struct syscall_params scp)
{
	long syscall, ret;
	long (*f)(struct syscall_params);
	sctrace_t tmp;
	syscall = scp.eax;

	/* read syscall handler pointer */
	spin_lock(&sys_call_lock);
	/* if this process was preempted before entering the
	 * synchronized area and the interceptor module was removed
	 * before this process had a change to run again, the retrieve
	 * the syscall handler address from the restored syscall table
	 * */
	if(table_backup != NULL)
		f = table_backup[syscall];
	else
		f = sys_call_table[syscall];

	spin_unlock(&sys_call_lock);

	ret = f(scp);
	if(table_backup != NULL) {
		if(current->pid == pid && table_backup[syscall] != NULL) {
			printk(LOG_LEVEL "PID=%d syscall=%ld intercepted!", pid, syscall);
			tmp.sc_no = syscall;
			tmp.sc_params = scp;
			tmp.ret = ret;
			if(add_history(tmp)) {
				printk(LOG_LEVEL "SCID: error add history\n");
			}
		}
	}

	return ret;
}

static int syscall_intercept(int syscall)
{
	spin_lock(&sys_call_lock);
	if(table_backup == NULL) {
		spin_unlock(&sys_call_lock);
		return -EBUSY;
	}
	if(table_backup[syscall] != NULL) {
		spin_unlock(&sys_call_lock);
		return -EINVAL;
	}
	table_backup[syscall] = sys_call_table[syscall];
	sys_call_table[syscall] = interceptor;
	spin_unlock(&sys_call_lock);
	return 0;
}

static int syscall_release(int syscall)
{
	spin_lock(&sys_call_lock);
	if(table_backup == NULL) {
		spin_unlock(&sys_call_lock);
		return -EBUSY;
	}
	if(table_backup[syscall] == NULL) {
		spin_unlock(&sys_call_lock);
		return -EINVAL;
	}
	sys_call_table[syscall] = table_backup[syscall];
	table_backup[syscall] = NULL;
	spin_unlock(&sys_call_lock);
	return 0;
}

static int set_pid(int pidarg) {
	struct pid* process_pid;
	struct task_struct* task;

	if(pidarg < 0)
		return -EINVAL;
	if(pidarg > 0) {
		process_pid = find_vpid(pidarg);
		if(process_pid == NULL)
			return -EINVAL;
		task = pid_task(process_pid, PIDTYPE_PID);
		if(task == NULL)
			return -EINVAL;
		pid = pidarg;
	} else {
		pid = 0;
		/* monitor all the processes! */
	}
	return 0;
}

static int scid_open(struct inode *inode, struct file *file)
{
	if(atomic_cmpxchg(&dev_access, 1, 0) != 1)
		return -EBUSY;
	printk(LOG_LEVEL "Device data file opened\n");
	return 0;
}

static int scid_release(struct inode *node, struct file *file)
{
	printk(LOG_LEVEL "Device data file closed\n");
	atomic_inc(&dev_access);
	return 0;
}

static int scid_read(struct file *file, char __user *user_buffer,
		size_t size, loff_t *offset)
{
	return 0;
}

static long scid_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
	int ret = 0, info;
	sctrace_t sctrace;

	printk(LOG_LEVEL "ioctl(%u, %lu)\n", cmd, arg);
	if(_IOC_DIR(cmd) == _IOC_WRITE) {
		if(_IOC_SIZE(cmd) == sizeof(int)) {
			ret = copy_from_user(&info, (void*)arg, sizeof(int));
			if(ret) {
				printk(LOG_LEVEL "SCID: ioctl copy_from_user error\n");
				return ret;
			}
		}
	}
	switch(cmd) {
	case IOCTL_SET_PID:
		ret = set_pid(info);
		break;

	case IOCTL_ADD_SYSCALL:
		ret = syscall_intercept(info);
		break;

	case IOCTL_DEL_SYSCALL:
		ret = syscall_release(info);
		break;

	case IOCTL_CLEAR_HISTORY:
		clear_history();
		break;

	case IOCTL_COUNT_HISTORY:
		ret = copy_to_user((void*)arg, &count, sizeof(int));
		if(ret) {
			printk(LOG_LEVEL "SCID: ioctl count error");
		}
		break;

	case IOCTL_READ_HISTORY:
		ret = head_remove_history(&sctrace);
		if(ret) {
			printk(LOG_LEVEL "SCID: ioctl head error");
			break;
		}
		ret = copy_to_user((void*)arg, &sctrace, sizeof(sctrace_t));
		if(ret)
			printk(LOG_LEVEL "SCID: ioctl head error");
		break;

	default:
		ret = -EINVAL;
	}
	return ret;
}

static const struct file_operations scid_fops = {
	.owner = THIS_MODULE,
	.open = scid_open,
	.release = scid_release,
	.read = scid_read,
	.unlocked_ioctl= scid_ioctl,
};

static struct miscdevice scid_dev = {
	.minor	= SCID_DEV_MINOR,
	.name	= SCID_DEV_NAME,
	.fops	= &scid_fops,
};

static int __init scid_init(void)
{
	int i, ret;
	struct proc_dir_entry* ent;

	printk(LOG_LEVEL "SCID: starting driver");
	atomic_set(&dev_access, 1);
	spin_lock_init(&sys_call_lock);
	spin_lock_init(&sc_history_lock);
	INIT_LIST_HEAD(&sc_history_list);

	spin_lock(&sys_call_lock);
	/* init backup copy of syscall table */
	table_backup = kmalloc( (my_nr_syscalls + 1) * sizeof(void*), GFP_ATOMIC);
	if(table_backup == NULL) {
		printk(LOG_LEVEL "SCID: kmalloc failed\n");
		ret = -ENOMEM;
		spin_unlock(&sys_call_lock);
		goto error;
	}
	/* a NULL value in backup table means that the syscall is not
	 * monitored for @pid */
	for(i = 0; i < my_nr_syscalls; i++)
		table_backup[i] = NULL;
	spin_unlock(&sys_call_lock);

	/* register misc device */
	ret = misc_register(&scid_dev);
	if(ret != 0) {
		printk(LOG_LEVEL "SCID: device register fail\n");
		goto error1;
	}
	/* create symlink to proc filesystem */
	ent = proc_symlink(SCID_DEV_NAME, NULL, "/dev/scid");
	if(ent == NULL) {
		printk(LOG_LEVEL "SCID: proc symlink creation fail\n");
		ret = -ENOMEM;
		goto error1;
	}
	printk(LOG_LEVEL "SCID: successful\n");
	return 0;
error1:
	kfree(table_backup);
error:
	printk(LOG_LEVEL "SCID: failed");
	return ret;
}

static void __exit scid_exit(void)
{
	int i;
	printk(LOG_LEVEL "SCID: stopping driver");
	spin_lock(&sys_call_lock);
	for(i = 0; i < my_nr_syscalls; i++)
		if(table_backup[i] != NULL)
			sys_call_table[i] = table_backup[i];
	spin_unlock(&sys_call_lock);
	kfree(table_backup);
	misc_deregister(&scid_dev);
	remove_proc_entry(SCID_DEV_NAME, NULL);
	clear_history();
	printk(LOG_LEVEL "SCID: done\n");
}

module_init(scid_init);
module_exit(scid_exit);
