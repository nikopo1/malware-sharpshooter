#include <linux/module.h>
#include <linux/init.h>
#include <linux/kernel.h>

#include <linux/netfilter.h>
#include <linux/netfilter_ipv4.h>
#include <linux/ip.h>
#include <linux/tcp.h>
#include <linux/udp.h>
#include <linux/icmp.h>
#include <linux/socket.h>

MODULE_DESCRIPTION("Network communication interceptor");
MODULE_AUTHOR("Nikopol");
MODULE_LICENSE("GPL");

#define LOG_LEVEL	KERN_ALERT

static struct nf_hook_ops my_hook;

static unsigned int my_hookfn(unsigned int hooknum,
		struct sk_buff *skb,
		const struct net_device *in,
		const struct net_device *out,
		int (*okfn)(struct sk_buff *)) {

	// typedef unsigned char *sk_buff_data_t; <- definitia
	struct iphdr*   ip;
	struct tcphdr*  tcp;
	struct udphdr*  udp;
	struct icmphdr* icmp;

	ip = ip_hdr(skb);
	if(ip->protocol == IPPROTO_TCP) {
		
		tcp = (struct tcphdr*)((__u32*)ip + ip->ihl);
		printk(LOG_LEVEL "TCP[%pI4:%hu][%pI4:%hu]\n", &ip->saddr, ntohs(tcp->source), &ip->daddr, ntohs(tcp->dest));

	} else if(ip->protocol == IPPROTO_UDP) {

		udp = (struct udphdr*)((__u32*)ip + ip->ihl);
		printk(LOG_LEVEL "UDP[%pI4:%hu][%pI4:%hu]\n", &ip->saddr, ntohs(udp->source), &ip->daddr, ntohs(udp->dest));

	} else if(ip->protocol == IPPROTO_ICMP) {
		icmp = (struct icmphdr*)((__u32*)ip + ip->ihl);
		printk(LOG_LEVEL "ICMP[%pI4][%pI4]Type=%d,Code=%d\n", &ip->saddr, &ip->daddr, icmp->type, icmp->code);

	}
	// unsigned char * data = skb->data;


	return NF_ACCEPT;
}

static int __init cmd_init(void)
{
	int ret;

	my_hook.hook	 = &my_hookfn;
	my_hook.owner	= THIS_MODULE;
	my_hook.pf	   = PF_INET;
	my_hook.hooknum  = NF_INET_PRE_ROUTING;
	my_hook.priority = NF_IP_PRI_FIRST;

	ret = nf_register_hook( &my_hook );
	if( ret < 0 )
		printk(LOG_LEVEL "Hook register failure: %d\n", ret);

	printk(LOG_LEVEL "Starting network intercepting...");
	return 0;
}

static void __exit cmd_exit(void)
{
	nf_unregister_hook( &my_hook );
	printk(LOG_LEVEL "Exit, stage left\n");
}

module_init(cmd_init);
module_exit(cmd_exit);
