#include <linux/module.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/cdev.h>

#include <linux/netfilter.h>
#include <linux/netfilter_ipv4.h>
#include <linux/ip.h>
#include <linux/tcp.h>
#include <linux/udp.h>
#include <linux/icmp.h>
#include <linux/socket.h>

#include "../include/interceptor.h"
#include <linux/miscdevice.h>

MODULE_DESCRIPTION("Network communication interceptor");
MODULE_AUTHOR("Nikopol");
MODULE_LICENSE("GPL");

#define BUFFER_SIZE	1024
#define LOG_LEVEL	KERN_ALERT

struct port_list_t {
	struct list_head list;
	unsigned short int src;
	unsigned short int dst;
	u8 protocol;
	atomic_t count;
	atomic_t size;
};

atomic_t access;
struct list_head port_list;
spinlock_t port_list_lock;

unsigned int buf_size; // 0 old, 1 new
char buf[BUFFER_SIZE];

static struct port_list_t* port_list_find(unsigned char protocol,
		unsigned short int src, unsigned short int dst) {

	struct port_list_t* pl;
	
	spin_lock(&port_list_lock);
	list_for_each_entry(pl, &port_list, list) {
		if(pl->protocol == protocol) {
			if(pl->src == src && pl->dst == dst) {
				spin_unlock(&port_list_lock);
				return pl;
			}
		}
	}
	spin_unlock(&port_list_lock);
	return NULL;
}

static int port_list_add(unsigned char protocol,
		unsigned short int src, unsigned short int dst) {

	struct port_list_t* pl;

	pl = port_list_find(0, 0, protocol);
	if(pl != NULL)
		return -EBUSY;
	pl = port_list_find(src, 0, protocol);
	if(pl != NULL)
		return -EBUSY;
	pl = port_list_find(0, dst, protocol);
	if(pl != NULL)
		return -EBUSY;

	spin_lock(&port_list_lock);
	pl = kmalloc(sizeof(struct port_list_t), GFP_KERNEL);
	if(pl == NULL)
		return -ENOMEM;

	pl->src = src;
	pl->dst = dst;
	pl->protocol = protocol;
	atomic_set(&pl->count, 0);
	atomic_set(&pl->size, 0);

	list_add(&pl->list, &port_list);
	spin_unlock(&port_list_lock);
	return 0;
}

static int port_list_del(unsigned char protocol,
		unsigned short int src, unsigned short int dst) {
	
	int ret = -EINVAL;
	struct port_list_t *p, *tmp;
	spin_lock(&port_list_lock);
	list_for_each_entry_safe(p, tmp, &port_list, list) {
		if(p->protocol == protocol) {
			if(p->src == src && p->dst == dst) {
				list_del(&p->list);
				kfree(p);
				ret = 0;
			}
		}
	}
	spin_unlock(&port_list_lock);
	return ret;
}

static void port_list_clear(void) {
	struct port_list_t *p, *tmp;
	spin_lock(&port_list_lock);
	list_for_each_entry_safe(p, tmp, &port_list, list) {
		list_del(&p->list);
		kfree(p);
	}
	spin_unlock(&port_list_lock);
}

static void port_list_print(void) {

	struct port_list_t *p;
	spin_lock(&port_list_lock);
	buf_size = snprintf(buf, sizeof(buf) - buf_size,
			"proto\tsource\tdest\tcount\tsize\n");

	list_for_each_entry(p, &port_list, list) {
		buf_size += snprintf(buf + buf_size, sizeof(buf) - buf_size,
				"%d\t%hu\t%hu\t%d\t%d\n",
				p->protocol,
				p->src,
				p->dst,
				atomic_read(&p->count),
				atomic_read(&p->size));
		if(buf_size == BUFFER_SIZE)
			break;
	}
	spin_unlock(&port_list_lock);
}

static struct nf_hook_ops my_hook;

static unsigned int my_hookfn(unsigned int hooknum,
		struct sk_buff *skb,
		const struct net_device *in,
		const struct net_device *out,
		int (*okfn)(struct sk_buff *)) {

	struct iphdr*   ip;
	struct tcphdr*  tcp;
	struct udphdr*  udp;
	struct icmphdr* icmp;

	struct port_list_t* pl;

	ip = ip_hdr(skb);	
	switch(ip->protocol) {
		case IPPROTO_TCP:
			tcp = (struct tcphdr*)((__u32*)ip + ip->ihl);
			pl = port_list_find(IPPROTO_TCP, tcp->dest, tcp->source);
			if(pl) {
				atomic_inc(&pl->count);
				atomic_add(ip->tot_len, &pl->size);
				printk(LOG_LEVEL "TCP[%pI4:%hu][%pI4:%hu]\n", 
						&ip->saddr, 
						ntohs(tcp->source), 
						&ip->daddr, 
						ntohs(tcp->dest));
			}
			break;
		case IPPROTO_UDP:
			udp = (struct udphdr*)((__u32*)ip + ip->ihl);
			pl = port_list_find(IPPROTO_UDP, udp->dest, udp->source);
			if(pl) {
				atomic_inc(&pl->count);
				atomic_add(ip->tot_len, &pl->size);
				printk(LOG_LEVEL "UDP[%pI4:%hu][%pI4:%hu]\n", 
						&ip->saddr, 
						ntohs(udp->source), 
						&ip->daddr, 
						ntohs(udp->dest));
			}
			break;
		case IPPROTO_ICMP:
			icmp = (struct icmphdr*)((__u32*)ip + ip->ihl);
			pl = port_list_find(IPPROTO_ICMP, 0, 0);
			if(pl) {
				atomic_inc(&pl->count);
				atomic_add(ip->tot_len, &pl->size);
				printk(LOG_LEVEL "ICMP[%pI4][%pI4]Type=%d,Code=%d\n", 
						&ip->saddr, 
						&ip->daddr, 
						icmp->type, 
						icmp->code);
			}
			break;
	}
	return NF_ACCEPT;
}

static int my_open(struct inode *inode, struct file *file) {
	buf_size = 0;

	if(atomic_cmpxchg(&access, 1, 0) != 1)
		return -EBUSY;

	printk(LOG_LEVEL "Device data file opened\n");
	return 0;
}

static int my_release(struct inode *node, struct file *f) {
	printk(LOG_LEVEL "Device data file closed\n");

	atomic_inc(&access);
	return 0;
}

static ssize_t my_read(struct file *file, char __user *user_buffer,
		size_t size, loff_t *offset)
{
	if(buf_size == 0)
		port_list_print();

	if(*offset >= buf_size)
		return 0;

	if(*offset + size > buf_size)
		size = buf_size - *offset;

	if(copy_to_user(user_buffer, buf + *offset, size))
		return -EINVAL;
	*offset = *offset + size;

	return size;
}


static long my_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
	
	int ret = 0;
	intercept_info_t info;

	ret = copy_from_user(&info, (void*)arg, sizeof(intercept_info_t));
	if(ret) {
		printk(LOG_LEVEL "ioctl: invalid intercept_info_t argument");
		return ret;
	}

	switch(cmd) {
		case START_INTERCEPT:
			ret = port_list_add(info.xport_protocol, info.source, info.dest);
			break;
		case STOP_INTERCEPT:
			ret = port_list_del(info.xport_protocol, info.source, info.dest);
			break;
	}
	return ret;
}

static const struct file_operations interceptor_fops = {
	.owner = THIS_MODULE,
	.open = my_open,
	.release = my_release,
	.read = my_read,
//	.write = my_write,
	.unlocked_ioctl = my_ioctl,
};

static struct miscdevice interceptor_dev = {
	.minor	= INTERCEPTOR_DEV_MINOR,
	.name	= "interceptor",
	.fops	= &interceptor_fops,
};

static int __init cmd_init(void)
{
	int ret;
	struct proc_dir_entry* ent;
	/* port list, atomic_t access and lock init */
	spin_lock_init(&port_list_lock);
	INIT_LIST_HEAD(&port_list);
	atomic_set(&access, 1);

	/* register device via miscdevice interface */
	ret = misc_register(&interceptor_dev);
	if(ret != 0) {
		printk(LOG_LEVEL "interceptor: device register failed");
		return ret;
	}

	ent = proc_symlink("interceptor", NULL, "/dev/interceptor");
	if(ent == NULL)
		return -ENOMEM;

	/* register netfilter hook */
	my_hook.hook = &my_hookfn;
	my_hook.owner = THIS_MODULE;
	my_hook.pf = PF_INET;
	my_hook.hooknum = NF_INET_PRE_ROUTING;
	my_hook.priority= NF_IP_PRI_FIRST;

	ret = nf_register_hook( &my_hook );
	if( ret != 0 )
		printk(LOG_LEVEL "interceptor: hook register failure");

	printk(LOG_LEVEL "Starting network intercepting...");
	return 0;
}

static void __exit cmd_exit(void)
{
	/* unregister device so we won't receive any more ioctl cmds */
	misc_deregister(&interceptor_dev);
	/* unregister intercepting hook */
	nf_unregister_hook( &my_hook );

	remove_proc_entry("interceptor", NULL);

	port_list_clear();
	printk(LOG_LEVEL "See ya later, aligator\n");
}

module_init(cmd_init);
module_exit(cmd_exit);
