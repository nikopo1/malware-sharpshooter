#include <linux/module.h>
#include <linux/init.h>
#include <linux/kernel.h>

#include <linux/netfilter.h>
#include <linux/netfilter_ipv4.h>
#include <linux/ip.h>
#include <linux/tcp.h>
#include <linux/udp.h>
#include <linux/icmp.h>
#include <linux/socket.h>

#include "interceptor.h"
#include <linux/miscdevice.h>

MODULE_DESCRIPTION("Network communication interceptor");
MODULE_AUTHOR("Nikopol");
MODULE_LICENSE("GPL");

#define LOG_LEVEL	KERN_ALERT

struct port_list_t {
	struct list_head list;
	unsigned short int src;
	unsigned short int dst;
	u8 protocol;
};
static struct list_head port_list;
static spinlock_t port_list_lock;

static struct port_list_t* port_list_find(int src, int dst, unsigned char protocol) {
	struct list_head* p;
	struct port_list_t* pl;
	
	spin_lock(&port_list_lock);
	list_for_each(p, &port_list) {
		pl = list_entry(p, struct port_list_t, list);
		if(pl->protocol == protocol) {
			if(pl->src == src && pl->dst == dst) {
				spin_unlock(&port_list_lock);
				return pl;
			}
		}
	}
	spin_unlock(&port_list_lock);
}

static struct nf_hook_ops my_hook;

static unsigned int my_hookfn(unsigned int hooknum,
		struct sk_buff *skb,
		const struct net_device *in,
		const struct net_device *out,
		int (*okfn)(struct sk_buff *)) {

	struct iphdr*   ip;
	struct tcphdr*  tcp;
	struct udphdr*  udp;
	struct icmphdr* icmp;

	ip = ip_hdr(skb);
	if(ip->protocol == IPPROTO_TCP) {
		
		tcp = (struct tcphdr*)((__u32*)ip + ip->ihl);
		printk(LOG_LEVEL "TCP[%pI4:%hu][%pI4:%hu]\n", &ip->saddr, ntohs(tcp->source), &ip->daddr, ntohs(tcp->dest));

	} else if(ip->protocol == IPPROTO_UDP) {

		udp = (struct udphdr*)((__u32*)ip + ip->ihl);
		printk(LOG_LEVEL "UDP[%pI4:%hu][%pI4:%hu]\n", &ip->saddr, ntohs(udp->source), &ip->daddr, ntohs(udp->dest));

	} else if(ip->protocol == IPPROTO_ICMP) {
		icmp = (struct icmphdr*)((__u32*)ip + ip->ihl);
		printk(LOG_LEVEL "ICMP[%pI4][%pI4]Type=%d,Code=%d\n", &ip->saddr, &ip->daddr, icmp->type, icmp->code);

	}
	// unsigned char * data = skb->data;


	return NF_ACCEPT;
}

static int my_open(struct inode *node, struct file *f) {
	return 0;
}

static int my_release(struct inode *node, struct file *f) {
	return 0;
}

static long my_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
	
	int ret = 0;
	switch(cmd) {
		case ADD_PORT_DESTINATION:
			printk(LOG_LEVEL "entered my ioctl in tracer add process");
			break;
		case DEL_PORT_DESTINATION:
			break;
		case ADD_PORT_SOURCE:
			break;
		case DEL_PORT_SOURCE:
			break;
		case ADD_ICMP:
			break;
		case DEL_ICMP:
			break;
	}
	return ret;
}

static const struct file_operations interceptor_fops = {
	.owner = THIS_MODULE,
	.open = my_open,
	.release = my_release,
//	.read = my_read,
//	.write = my_write,
	.unlocked_ioctl = my_ioctl,
};

static struct miscdevice interceptor_dev = {
	.minor	= INTERCEPTOR_DEV_MINOR,
	.name	= "interceptor",
	.fops	= &interceptor_fops,
};

static int __init cmd_init(void)
{
	int ret;

	/* port list and lock init */
	spin_lock_init(&port_list_lock);
	INIT_LIST_HEAD(&port_list);

	/* register device via miscdevice interface */
	ret = misc_register(&interceptor_dev);
	if(ret != 0) {
		printk(LOG_LEVEL "interceptor: device register failed");
		return ret;
	}

	/* register netfilter hook */
	my_hook.hook = &my_hookfn;
	my_hook.owner = THIS_MODULE;
	my_hook.pf = PF_INET;
	my_hook.hooknum = NF_INET_PRE_ROUTING;
	my_hook.priority= NF_IP_PRI_FIRST;

	ret = nf_register_hook( &my_hook );
	if( ret != 0 )
		printk(LOG_LEVEL "interceptor: hook register failure");

	printk(LOG_LEVEL "Starting network intercepting...");
	return 0;
}

static void __exit cmd_exit(void)
{
	/* unregister device so we won't receive any more ioctl cmds */
	misc_deregister(&interceptor_dev);
	/* unregister intercepting hook */
	nf_unregister_hook( &my_hook );

	printk(LOG_LEVEL "See ya later, aligator\n");
}

module_init(cmd_init);
module_exit(cmd_exit);
